coherence_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Store1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Store2 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Store3 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Store4 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
booleanExpr_list: [VarExpr('x')]
scalarsetVars: [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('auxDATA')]
coherence_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Store1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Store2 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Store3 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
coherence_Store4 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
c51_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
c51_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
c51_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
c51_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA')], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
c51_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
c51_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
c51_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
c51_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
c51_Store1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
c51_Store2 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
c51_Store3 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
c51_Store4 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
booleanExpr_list: [VarExpr('x')]
scalarsetVars: [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('auxDATA')]
c.inv_instance: {'coherence': OpExpr(->, 1 != 2, n[1].st = C ->   n[2].st != C), 'c51': OpExpr(->, 1 != 2, (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
ori_inv: defaultdict(<class 'list'>, {'coherence': [OpExpr(->, 1 != 2, n[1].st = C ->   n[2].st != C)], 'c51': [OpExpr(->, 1 != 2, (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))]})
coherence_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
current_inv: coherence
val: T <class 'str'>
6. F: [n[1].st == I, n[1].st' == T, n[2].st == n[2].st', And(n[1].st' == C, n[2].st' == C), Implies(n[1].st == C, n[2].st != C)]
unsat
coherence_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
current_inv: coherence
val: T <class 'str'>
6. F: [n[2].st == I, n[2].st' == T, n[1].st == n[1].st', And(n[1].st' == C, n[2].st' == C), Implies(n[1].st == C, n[2].st != C)]
unsat
coherence_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
current_inv: coherence
val: C <class 'str'>
val: False <class 'bool'>
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [And(n[1].st == T, x == True), n[1].st' == C, x' == False, n[1].data' == memDATA, n[2].st == n[2].st', And(n[1].st' == C, n[2].st' == C), Implies(n[1].st == C, n[2].st != C), Or(n[1].data' == 1, n[1].data' == 2), Or(memDATA == 1, memDATA == 2)]
sat
解是：

[memDATA = 1,
 n[1].st' = C,
 n[1].st = T,
 x = True,
 n[1].data' = 1,
 n[2].st' = C,
 n[2].st = C,
 x' = False]
invlist1: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[2].st, C)]
invlist2: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, n[2].st, C)]
paraVars: [{'1': 'NODE'}, {'2': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, n[1].st = C ->   n[2].st != C)]
set(self.enum_notEqulVars): {n[2].st}
set(self.enum_EqulVars): {n[2].st, n[2].st', n[1].st, n[1].st'}
self.enum_notEqulVars_map: {'n[2].st': ['C']}
1111: [And(n[1].st == T, x == True),
 n[1].st' == C,
 x' == False,
 n[1].data' == memDATA,
 n[2].st == n[2].st',
 And(n[1].st' == C, n[2].st' == C),
 Implies(n[1].st == C, n[2].st != C),
 Or(n[1].data' == 1, n[1].data' == 2),
 Or(memDATA == 1, memDATA == 2)]
checkVars: []
solution: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, n[2].st, C)]
new_inv: invariant "coherence_Crit1"
   !(n[2].st = C & x = true & n[1].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true)]
new_inv: invariant "coherence_Crit1"
   !(x = true & n[1].st = T);
counter_ex: ['coherence_Crit1']
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, n[2].st, C)]
new_inv: invariant "coherence_Crit1"
   !(n[2].st = C & n[1].st = T);
counter_ex: ['coherence_Crit1']
sublist: [OpExpr(=, x, true), OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, x, true), OpExpr(=, n[2].st, C)]
new_inv: invariant "coherence_Crit1"
   !(n[2].st = C & x = true);
No cti found. The invariants are OK.
sublist: [OpExpr(=, x, true)]
inv_list [OpExpr(=, x, true)]
new_inv: invariant "coherence_Crit1"
   !(x = true);
counter_ex: ['coherence_Crit1']
sublist: [OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[2].st, C)]
new_inv: invariant "coherence_Crit1"
   !(n[2].st = C);
counter_ex: ['coherence_Crit1']
self.aux_inv1: !(n[2].st = C & x = true)
self.aux_inv2: !(n[2].st = C & x = true)
invPattern: []
invPattern_dict: {}
matches: {'n[2].st'}
var.keys(): 1
var.keys(): 2
var_list: []
Oplist: ['n[_].st = C', 'x = true']
add pattern: !(n[2].st = C & x = true)
inv_str:
 !(n[2].st = C & x = true)
;
coherence_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
current_inv: coherence
val: C <class 'str'>
val: False <class 'bool'>
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [And(n[2].st == T, x == True), n[2].st' == C, x' == False, n[2].data' == memDATA, n[1].st == n[1].st', And(n[1].st' == C, n[2].st' == C), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Or(n[2].data' == 1, n[2].data' == 2), Or(memDATA == 1, memDATA == 2)]
sat
解是：

[memDATA = 1,
 n[1].st' = C,
 n[1].st = C,
 x = True,
 n[2].data' = 1,
 x' = False,
 n[2].st' = C,
 n[2].st = T]
invlist1: [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[1].st, C)]
invlist2: [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, n[1].st, C)]
paraVars: [{'2': 'NODE'}, {'1': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, n[1].st = C ->   n[2].st != C), NegExpr(n[2].st = C & x = true)]
set(self.enum_notEqulVars): {n[2].st}
set(self.enum_EqulVars): {n[2].st, n[2].st', n[1].st, n[1].st'}
self.enum_notEqulVars_map: {'n[2].st': ['C']}
1111: [And(n[2].st == T, x == True),
 n[2].st' == C,
 x' == False,
 n[2].data' == memDATA,
 n[1].st == n[1].st',
 And(n[1].st' == C, n[2].st' == C),
 Implies(n[1].st == C, n[2].st != C),
 Implies(n[2].st == C, x != True),
 Or(n[2].data' == 1, n[2].data' == 2),
 Or(memDATA == 1, memDATA == 2)]
checkVars: []
solution: [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, n[1].st, C)]
inv_list [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, n[1].st, C)]
new_inv: invariant "coherence_Crit2"
   !(n[1].st = C & x = true & n[2].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, T), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[2].st, T), OpExpr(=, x, true)]
new_inv: invariant "coherence_Crit2"
   !(x = true & n[2].st = T);
counter_ex: ['coherence_Crit2']
sublist: [OpExpr(=, n[2].st, T), OpExpr(=, n[1].st, C)]
inv_list [OpExpr(=, n[2].st, T), OpExpr(=, n[1].st, C)]
new_inv: invariant "coherence_Crit2"
   !(n[1].st = C & n[2].st = T);
counter_ex: ['coherence_Crit2']
sublist: [OpExpr(=, x, true), OpExpr(=, n[1].st, C)]
inv_list [OpExpr(=, x, true), OpExpr(=, n[1].st, C)]
new_inv: invariant "coherence_Crit2"
   !(n[1].st = C & x = true);
No cti found. The invariants are OK.
sublist: [OpExpr(=, x, true)]
inv_list [OpExpr(=, x, true)]
new_inv: invariant "coherence_Crit2"
   !(x = true);
counter_ex: ['coherence_Crit2']
sublist: [OpExpr(=, n[1].st, C)]
inv_list [OpExpr(=, n[1].st, C)]
new_inv: invariant "coherence_Crit2"
   !(n[1].st = C);
counter_ex: ['coherence_Crit2']
self.aux_inv1: !(n[1].st = C & x = true)
self.aux_inv2: !(n[1].st = C & x = true)
invPattern: [['n[_].st = C', 'x = true']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}}
matches: {'n[1].st'}
var.keys(): 2
var.keys(): 1
var_list: []
Oplist: ['n[_].st = C', 'x = true']
var出现次数： {}
{}
exist self.aux_inv: !(n[1].st = C & x = true)
coherence_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
current_inv: coherence
val: E <class 'str'>
6. F: [n[1].st == C, n[1].st' == E, n[2].st == n[2].st', And(n[1].st' == C, n[2].st' == C), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True)]
unsat
coherence_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
current_inv: coherence
val: E <class 'str'>
6. F: [n[2].st == C, n[2].st' == E, n[1].st == n[1].st', And(n[1].st' == C, n[2].st' == C), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True)]
unsat
coherence_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
current_inv: coherence
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
6. F: [n[1].st == E, n[1].st' == I, x' == True, memDATA' == n[1].data, n[2].st == n[2].st', And(n[1].st' == C, n[2].st' == C), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Or(memDATA' == 1, memDATA' == 2), Or(n[1].data == 1, n[1].data == 2)]
unsat
coherence_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 -> (  n[1].st = C ->   n[2].st != C))}
current_inv: coherence
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [n[2].st == E, n[2].st' == I, x' == True, memDATA' == n[2].data, n[1].st == n[1].st', And(n[1].st' == C, n[2].st' == C), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Or(memDATA' == 1, memDATA' == 2), Or(n[2].data == 1, n[2].data == 2)]
unsat
c51_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
current_inv: c51
val: T <class 'str'>
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
6. F: [n[1].st == I, n[1].st' == T, n[1].data == n[1].data', auxDATA == auxDATA', n[2].st == n[2].st', n[2].data == n[2].data', Implies(Implies(n[1].st' == C, n[1].data' == auxDATA'),
        And(n[2].st' == C, n[2].data' != auxDATA')), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Or(n[1].data == 1, n[1].data == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data == 1, n[2].data == 2), Or(n[2].data' == 1, n[2].data' == 2)]
unsat
c51_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
current_inv: c51
val: T <class 'str'>
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
6. F: [n[2].st == I, n[2].st' == T, n[1].st == n[1].st', n[1].data == n[1].data', auxDATA == auxDATA', n[2].data == n[2].data', Implies(Implies(n[1].st' == C, n[1].data' == auxDATA'),
        And(n[2].st' == C, n[2].data' != auxDATA')), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Or(n[1].data == 1, n[1].data == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data == 1, n[2].data == 2), Or(n[2].data' == 1, n[2].data' == 2)]
unsat
c51_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
current_inv: c51
val: C <class 'str'>
val: False <class 'bool'>
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
6. F: [And(n[1].st == T, x == True), n[1].st' == C, x' == False, n[1].data' == memDATA, auxDATA == auxDATA', n[2].st == n[2].st', n[2].data == n[2].data', Implies(Implies(n[1].st' == C, n[1].data' == auxDATA'),
        And(n[2].st' == C, n[2].data' != auxDATA')), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Or(n[1].data' == 1, n[1].data' == 2), Or(memDATA == 1, memDATA == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data == 1, n[2].data == 2), Or(n[2].data' == 1, n[2].data' == 2), Or(n[1].data == 1, n[1].data == 2)]
sat
解是：

[n[2].st' = I,
 n[2].data' = 1,
 memDATA = 1,
 n[1].data = 2,
 auxDATA' = 2,
 auxDATA = 2,
 n[1].st = T,
 n[2].st = I,
 n[1].st' = C,
 n[2].data = 1,
 x = True,
 n[1].data' = 1,
 x' = False]
invlist1: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1), OpExpr(=, n[1].data, 2)]
paraVars: [{'1': 'NODE'}, {'2': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))]
set(self.enum_notEqulVars): set()
set(self.enum_EqulVars): {n[1].st, n[2].data, n[1].st', n[2].st, n[2].st', auxDATA}
self.enum_notEqulVars_map: {}
1111: [And(n[1].st == T, x == True),
 n[1].st' == C,
 x' == False,
 n[1].data' == memDATA,
 auxDATA == auxDATA',
 n[2].st == n[2].st',
 n[2].data == n[2].data',
 Implies(Implies(n[1].st' == C, n[1].data' == auxDATA'),
         And(n[2].st' == C, n[2].data' != auxDATA')),
 And(Implies(n[1].st == C, n[1].data == auxDATA),
     Implies(n[2].st == C, n[2].data == auxDATA)),
 Or(n[1].data' == 1, n[1].data' == 2),
 Or(memDATA == 1, memDATA == 2),
 Or(auxDATA == 1, auxDATA == 2),
 Or(auxDATA' == 1, auxDATA' == 2),
 Or(n[2].data == 1, n[2].data == 2),
 Or(n[2].data' == 1, n[2].data' == 2),
 Or(n[1].data == 1, n[1].data == 2)]
checkVars: []
solution: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1), OpExpr(=, n[1].data, 2)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1), OpExpr(=, n[1].data, 2)]
new_inv: invariant "c51_Crit1"
   !(n[1].data = 2 & n[2].data = 1 & n[2].st = I & auxDATA = 2 & memDATA = 1 & x = true & n[1].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1)]
new_inv: invariant "c51_Crit1"
   !(n[2].data = 1 & n[2].st = I & auxDATA = 2 & memDATA = 1 & x = true & n[1].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I)]
new_inv: invariant "c51_Crit1"
   !(n[2].st = I & auxDATA = 2 & memDATA = 1 & x = true & n[1].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2)]
new_inv: invariant "c51_Crit1"
   !(auxDATA = 2 & memDATA = 1 & x = true & n[1].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1)]
new_inv: invariant "c51_Crit1"
   !(memDATA = 1 & x = true & n[1].st = T);
counter_ex: ['c51_Crit1']
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, auxDATA, 2)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, auxDATA, 2)]
new_inv: invariant "c51_Crit1"
   !(auxDATA = 2 & x = true & n[1].st = T);
counter_ex: ['c51_Crit1']
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2)]
new_inv: invariant "c51_Crit1"
   !(auxDATA = 2 & memDATA = 1 & n[1].st = T);
counter_ex: ['c51_Crit1']
sublist: [OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2)]
inv_list [OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2)]
new_inv: invariant "c51_Crit1"
   !(auxDATA = 2 & memDATA = 1 & x = true);
No cti found. The invariants are OK.
sublist: [OpExpr(=, x, true), OpExpr(=, memDATA, 1)]
inv_list [OpExpr(=, x, true), OpExpr(=, memDATA, 1)]
new_inv: invariant "c51_Crit1"
   !(memDATA = 1 & x = true);
counter_ex: ['c51_Crit1']
sublist: [OpExpr(=, x, true), OpExpr(=, auxDATA, 2)]
inv_list [OpExpr(=, x, true), OpExpr(=, auxDATA, 2)]
new_inv: invariant "c51_Crit1"
   !(auxDATA = 2 & x = true);
counter_ex: ['c51_Crit1']
sublist: [OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2)]
inv_list [OpExpr(=, memDATA, 1), OpExpr(=, auxDATA, 2)]
new_inv: invariant "c51_Crit1"
   !(auxDATA = 2 & memDATA = 1);
counter_ex: ['c51_Crit1']
self.aux_inv1: !(auxDATA = 2 & memDATA = 1 & x = true)
self.aux_inv2: !(memDATA != auxDATA & x = true)
invPattern: [['n[_].st = C', 'x = true']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}}
matches: set()
var.keys(): 1
var.keys(): 2
var_list: []
Oplist: ['memDATA != auxDATA', 'x = true']
var出现次数： {}
{}
add pattern: !(memDATA != auxDATA & x = true)
inv_str:
 !(memDATA != auxDATA & x = true)
;
c51_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA')], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
current_inv: c51
val: C <class 'str'>
val: False <class 'bool'>
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [And(n[2].st == T, x == True), n[2].st' == C, x' == False, n[2].data' == memDATA, n[1].st == n[1].st', n[1].data == n[1].data', auxDATA == auxDATA', Implies(Implies(n[1].st' == C, n[1].data' == auxDATA'),
        And(n[2].st' == C, n[2].data' != auxDATA')), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Or(n[2].data' == 1, n[2].data' == 2), Or(memDATA == 1, memDATA == 2), Or(n[1].data == 1, n[1].data == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data == 1, n[2].data == 2)]
unsat
c51_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
current_inv: c51
val: E <class 'str'>
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[1].st == C, n[1].st' == E, n[1].data == n[1].data', auxDATA == auxDATA', n[2].st == n[2].st', n[2].data == n[2].data', Implies(Implies(n[1].st' == C, n[1].data' == auxDATA'),
        And(n[2].st' == C, n[2].data' != auxDATA')), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Or(n[1].data == 1, n[1].data == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data == 1, n[2].data == 2), Or(n[2].data' == 1, n[2].data' == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
current_inv: c51
val: E <class 'str'>
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[2].st == C, n[2].st' == E, n[1].st == n[1].st', n[1].data == n[1].data', auxDATA == auxDATA', n[2].data == n[2].data', Implies(Implies(n[1].st' == C, n[1].data' == auxDATA'),
        And(n[2].st' == C, n[2].data' != auxDATA')), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Or(n[1].data == 1, n[1].data == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data == 1, n[2].data == 2), Or(n[2].data' == 1, n[2].data' == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
current_inv: c51
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[1].st == E, n[1].st' == I, x' == True, memDATA' == n[1].data, n[1].data == n[1].data', auxDATA == auxDATA', n[2].st == n[2].st', n[2].data == n[2].data', Implies(Implies(n[1].st' == C, n[1].data' == auxDATA'),
        And(n[2].st' == C, n[2].data' != auxDATA')), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Or(memDATA' == 1, memDATA' == 2), Or(n[1].data == 1, n[1].data == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data == 1, n[2].data == 2), Or(n[2].data' == 1, n[2].data' == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
current_inv: c51
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[2].st == E, n[2].st' == I, x' == True, memDATA' == n[2].data, n[1].st == n[1].st', n[1].data == n[1].data', auxDATA == auxDATA', n[2].data == n[2].data', Implies(Implies(n[1].st' == C, n[1].data' == auxDATA'),
        And(n[2].st' == C, n[2].data' != auxDATA')), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Or(memDATA' == 1, memDATA' == 2), Or(n[2].data == 1, n[2].data == 2), Or(n[1].data == 1, n[1].data == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data' == 1, n[2].data' == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Store1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
current_inv: c51
val: 1 <class 'int'>
val: 1 <class 'int'>
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[1].st == C, auxDATA' == 1, n[1].data' == 1, n[1].st == n[1].st', n[2].st == n[2].st', n[2].data == n[2].data', Implies(Implies(n[1].st' == C, n[1].data' == auxDATA'),
        And(n[2].st' == C, n[2].data' != auxDATA')), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Or(auxDATA' == 1, auxDATA' == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(n[2].data == 1, n[2].data == 2), Or(n[2].data' == 1, n[2].data' == 2), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(memDATA == 1, memDATA == 2)]
sat
解是：

[x = False,
 memDATA = 1,
 auxDATA' = 1,
 n[1].st = C,
 n[1].data = 2,
 n[2].st' = C,
 n[2].st = C,
 n[1].st' = C,
 n[2].data' = 2,
 n[2].data = 2,
 n[1].data' = 1,
 auxDATA = 2]
invlist1: [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, C), OpExpr(=, n[2].data, 2), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 2), OpExpr(=, memDATA, 1), OpExpr(=, x, false)]
paraVars: [{'1': 'NODE'}, {'2': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA)), NegExpr(memDATA != auxDATA & x = true)]
set(self.enum_notEqulVars): set()
set(self.enum_EqulVars): {n[1].st, n[2].data, n[1].st', n[2].st, n[2].st'}
self.enum_notEqulVars_map: {}
1111: [n[1].st == C,
 auxDATA' == 1,
 n[1].data' == 1,
 n[1].st == n[1].st',
 n[2].st == n[2].st',
 n[2].data == n[2].data',
 Implies(Implies(n[1].st' == C, n[1].data' == auxDATA'),
         And(n[2].st' == C, n[2].data' != auxDATA')),
 And(Implies(n[1].st == C, n[1].data == auxDATA),
     Implies(n[2].st == C, n[2].data == auxDATA)),
 Implies(memDATA != auxDATA, x != True),
 Or(auxDATA' == 1, auxDATA' == 2),
 Or(n[1].data' == 1, n[1].data' == 2),
 Or(n[2].data == 1, n[2].data == 2),
 Or(n[2].data' == 1, n[2].data' == 2),
 Or(n[1].data == 1, n[1].data == 2),
 Or(auxDATA == 1, auxDATA == 2),
 Or(memDATA == 1, memDATA == 2)]
checkVars: []
solution: [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, C), OpExpr(=, n[2].data, 2), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 2), OpExpr(=, memDATA, 1), OpExpr(=, x, false)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, C), OpExpr(=, n[2].data, 2), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 2), OpExpr(=, memDATA, 1), OpExpr(=, x, false)]
new_inv: invariant "c51_Store1"
   !(x = false & memDATA = 1 & auxDATA = 2 & n[1].data = 2 & n[2].data = 2 & n[2].st = C & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, C), OpExpr(=, n[2].data, 2), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 2), OpExpr(=, memDATA, 1)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, C), OpExpr(=, n[2].data, 2), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 2), OpExpr(=, memDATA, 1)]
new_inv: invariant "c51_Store1"
   !(memDATA = 1 & auxDATA = 2 & n[1].data = 2 & n[2].data = 2 & n[2].st = C & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, C), OpExpr(=, n[2].data, 2), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 2)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, C), OpExpr(=, n[2].data, 2), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 2)]
new_inv: invariant "c51_Store1"
   !(auxDATA = 2 & n[1].data = 2 & n[2].data = 2 & n[2].st = C & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, C), OpExpr(=, n[2].data, 2), OpExpr(=, n[1].data, 2)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, C), OpExpr(=, n[2].data, 2), OpExpr(=, n[1].data, 2)]
new_inv: invariant "c51_Store1"
   !(n[1].data = 2 & n[2].data = 2 & n[2].st = C & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, C), OpExpr(=, n[2].data, 2)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, C), OpExpr(=, n[2].data, 2)]
new_inv: invariant "c51_Store1"
   !(n[2].data = 2 & n[2].st = C & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, C)]
new_inv: invariant "c51_Store1"
   !(n[2].st = C & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C)]
inv_list [OpExpr(=, n[1].st, C)]
new_inv: invariant "c51_Store1"
   !(n[1].st = C);
counter_ex: ['c51_Store1']
sublist: [OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[2].st, C)]
new_inv: invariant "c51_Store1"
   !(n[2].st = C);
counter_ex: ['c51_Store1']
self.aux_inv1: !(n[2].st = C & n[1].st = C)
self.aux_inv2: !(n[2].st = C & n[1].st = C)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}}
matches: {'n[2].st', 'n[1].st'}
var.keys(): 1
var.keys(): 2
var_list: []
Oplist: ['n[_].st = C', 'n[_].st = C']
var出现次数： {}
{}
var出现次数： {}
{}
add pattern: !(n[2].st = C & n[1].st = C)
inv_str:
 !(n[2].st = C & n[1].st = C)
;
c51_Store2 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
current_inv: c51
val: 2 <class 'int'>
val: 2 <class 'int'>
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[1].st == C, auxDATA' == 2, n[1].data' == 2, n[1].st == n[1].st', n[2].st == n[2].st', n[2].data == n[2].data', Implies(Implies(n[1].st' == C, n[1].data' == auxDATA'),
        And(n[2].st' == C, n[2].data' != auxDATA')), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Or(auxDATA' == 1, auxDATA' == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(n[2].data == 1, n[2].data == 2), Or(n[2].data' == 1, n[2].data' == 2), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Store3 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
current_inv: c51
val: 1 <class 'int'>
val: 1 <class 'int'>
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[2].st == C, auxDATA' == 1, n[2].data' == 1, n[1].st == n[1].st', n[1].data == n[1].data', n[2].st == n[2].st', Implies(Implies(n[1].st' == C, n[1].data' == auxDATA'),
        And(n[2].st' == C, n[2].data' != auxDATA')), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data' == 1, n[2].data' == 2), Or(n[1].data == 1, n[1].data == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Store4 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(1 != 2 ->   (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA))}
current_inv: c51
val: 2 <class 'int'>
val: 2 <class 'int'>
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[2].st == C, auxDATA' == 2, n[2].data' == 2, n[1].st == n[1].st', n[1].data == n[1].data', n[2].st == n[2].st', Implies(Implies(n[1].st' == C, n[1].data' == auxDATA'),
        And(n[2].st' == C, n[2].data' != auxDATA')), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data' == 1, n[2].data' == 2), Or(n[1].data == 1, n[1].data == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
unsat
list0: {'coherence_Crit1_1': NegExpr(n[2].st = C & x = true), 'c51_Crit1_1': NegExpr(memDATA != auxDATA & x = true), 'c51_Store1_1': NegExpr(n[2].st = C & n[1].st = C)}
new_inv: !(n[2].st = C & x = true)
coherence_Crit1_1_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), VarExpr('x')], '!inv': NegExpr(!(n[2].st = C & x = true))}
coherence_Crit1_1_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [VarExpr('x')], '!inv': NegExpr(!(n[2].st = C & x = true))}
coherence_Crit1_1_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & x = true))}
coherence_Crit1_1_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [], '!inv': NegExpr(!(n[2].st = C & x = true))}
coherence_Crit1_1_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), VarExpr('x')], '!inv': NegExpr(!(n[2].st = C & x = true))}
coherence_Crit1_1_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [VarExpr('x')], '!inv': NegExpr(!(n[2].st = C & x = true))}
coherence_Crit1_1_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & x = true))}
coherence_Crit1_1_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [], '!inv': NegExpr(!(n[2].st = C & x = true))}
coherence_Crit1_1_Store1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), VarExpr('x')], '!inv': NegExpr(!(n[2].st = C & x = true))}
coherence_Crit1_1_Store2 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), VarExpr('x')], '!inv': NegExpr(!(n[2].st = C & x = true))}
coherence_Crit1_1_Store3 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), VarExpr('x')], '!inv': NegExpr(!(n[2].st = C & x = true))}
coherence_Crit1_1_Store4 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), VarExpr('x')], '!inv': NegExpr(!(n[2].st = C & x = true))}
booleanExpr_list: [VarExpr('x')]
scalarsetVars: [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('auxDATA')]
list1: {'c51_Crit1_1': NegExpr(memDATA != auxDATA & x = true), 'c51_Store1_1': NegExpr(n[2].st = C & n[1].st = C)}
coherence_Crit1_1_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [VarExpr('x')], '!inv': NegExpr(!(n[2].st = C & x = true))}
current_inv: coherence
val: T <class 'str'>
6. F: [n[2].st == I, n[2].st' == T, x == x', And(n[2].st' == C, x' == True), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True)]
unsat
coherence_Crit1_1_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & x = true))}
current_inv: coherence
val: C <class 'str'>
val: False <class 'bool'>
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [And(n[1].st == T, x == True), n[1].st' == C, x' == False, n[1].data' == memDATA, n[2].st == n[2].st', And(n[2].st' == C, x' == True), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Or(n[1].data' == 1, n[1].data' == 2), Or(memDATA == 1, memDATA == 2)]
unsat
coherence_Crit1_1_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [], '!inv': NegExpr(!(n[2].st = C & x = true))}
current_inv: coherence
val: C <class 'str'>
val: False <class 'bool'>
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [And(n[2].st == T, x == True), n[2].st' == C, x' == False, n[2].data' == memDATA, And(n[2].st' == C, x' == True), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Or(n[2].data' == 1, n[2].data' == 2), Or(memDATA == 1, memDATA == 2)]
unsat
coherence_Crit1_1_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [VarExpr('x')], '!inv': NegExpr(!(n[2].st = C & x = true))}
current_inv: coherence
val: E <class 'str'>
6. F: [n[2].st == C, n[2].st' == E, x == x', And(n[2].st' == C, x' == True), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True)]
unsat
coherence_Crit1_1_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & x = true))}
current_inv: coherence
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
6. F: [n[1].st == E, n[1].st' == I, x' == True, memDATA' == n[1].data, n[2].st == n[2].st', And(n[2].st' == C, x' == True), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Or(memDATA' == 1, memDATA' == 2), Or(n[1].data == 1, n[1].data == 2)]
sat
解是：

[n[1].data = 1,
 n[1].st' = I,
 n[1].st = E,
 x = False,
 n[2].st' = C,
 n[2].st = C,
 memDATA' = 1,
 x' = True]
invlist1: [OpExpr(=, n[1].st, E), OpExpr(=, n[1].data, 1), OpExpr(=, n[2].st, C), OpExpr(=, x, false)]
invlist2: [OpExpr(=, n[1].st, E), OpExpr(=, n[2].st, C), OpExpr(=, x, false)]
paraVars: [{'1': 'NODE'}, {'2': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, n[1].st = C ->   n[2].st != C), NegExpr(n[2].st = C & x = true)]
set(self.enum_notEqulVars): {n[2].st}
set(self.enum_EqulVars): {n[2].st, n[2].st', n[1].st, n[1].st'}
self.enum_notEqulVars_map: {'n[2].st': ['C']}
1111: [n[1].st == E,
 n[1].st' == I,
 x' == True,
 memDATA' == n[1].data,
 n[2].st == n[2].st',
 And(n[2].st' == C, x' == True),
 Implies(n[1].st == C, n[2].st != C),
 Implies(n[2].st == C, x != True),
 Or(memDATA' == 1, memDATA' == 2),
 Or(n[1].data == 1, n[1].data == 2)]
checkVars: []
solution: [OpExpr(=, n[1].st, E), OpExpr(=, n[2].st, C), OpExpr(=, x, false)]
inv_list [OpExpr(=, n[1].st, E), OpExpr(=, n[2].st, C), OpExpr(=, x, false)]
new_inv: invariant "coherence_Crit1_1_Idle1"
   !(x = false & n[2].st = C & n[1].st = E);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, E), OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[1].st, E), OpExpr(=, n[2].st, C)]
new_inv: invariant "coherence_Crit1_1_Idle1"
   !(n[2].st = C & n[1].st = E);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, E)]
inv_list [OpExpr(=, n[1].st, E)]
new_inv: invariant "coherence_Crit1_1_Idle1"
   !(n[1].st = E);
counter_ex: ['coherence_Crit1_1_Idle1']
sublist: [OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[2].st, C)]
new_inv: invariant "coherence_Crit1_1_Idle1"
   !(n[2].st = C);
counter_ex: ['coherence_Crit1_1_Idle1']
self.aux_inv1: !(n[2].st = C & n[1].st = E)
self.aux_inv2: !(n[2].st = C & n[1].st = E)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}}
matches: {'n[2].st', 'n[1].st'}
var.keys(): 1
var.keys(): 2
var_list: []
Oplist: ['n[_].st = C', 'n[_].st = E']
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
add pattern: !(n[2].st = C & n[1].st = E)
inv_str:
 !(n[2].st = C & n[1].st = E)
;
coherence_Crit1_1_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [], '!inv': NegExpr(!(n[2].st = C & x = true))}
current_inv: coherence
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [n[2].st == E, n[2].st' == I, x' == True, memDATA' == n[2].data, And(n[2].st' == C, x' == True), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Or(memDATA' == 1, memDATA' == 2), Or(n[2].data == 1, n[2].data == 2)]
unsat
list0: {'c51_Crit1_1': NegExpr(memDATA != auxDATA & x = true), 'c51_Store1_1': NegExpr(n[2].st = C & n[1].st = C), 'coherence_Crit1_1_Idle1_1': NegExpr(n[2].st = C & n[1].st = E)}
new_inv: !(memDATA != auxDATA & x = true)
c51_Crit1_1_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [VarExpr('memDATA'), VarExpr('auxDATA'), VarExpr('x')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
c51_Crit1_1_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [VarExpr('memDATA'), VarExpr('auxDATA'), VarExpr('x')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
c51_Crit1_1_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [VarExpr('memDATA'), VarExpr('auxDATA')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
c51_Crit1_1_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [VarExpr('memDATA'), VarExpr('auxDATA')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
c51_Crit1_1_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [VarExpr('memDATA'), VarExpr('auxDATA'), VarExpr('x')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
c51_Crit1_1_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [VarExpr('memDATA'), VarExpr('auxDATA'), VarExpr('x')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
c51_Crit1_1_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [VarExpr('auxDATA')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
c51_Crit1_1_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [VarExpr('auxDATA')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
c51_Crit1_1_Store1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [VarExpr('memDATA'), VarExpr('x')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
c51_Crit1_1_Store2 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [VarExpr('memDATA'), VarExpr('x')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
c51_Crit1_1_Store3 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [VarExpr('memDATA'), VarExpr('x')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
c51_Crit1_1_Store4 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [VarExpr('memDATA'), VarExpr('x')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
booleanExpr_list: [VarExpr('x')]
scalarsetVars: [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('auxDATA')]
list1: {'c51_Store1_1': NegExpr(n[2].st = C & n[1].st = C), 'coherence_Crit1_1_Idle1_1': NegExpr(n[2].st = C & n[1].st = E)}
c51_Crit1_1_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [VarExpr('memDATA'), VarExpr('auxDATA')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
current_inv: c51
val: C <class 'str'>
val: False <class 'bool'>
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [And(n[1].st == T, x == True), n[1].st' == C, x' == False, n[1].data' == memDATA, memDATA == memDATA', auxDATA == auxDATA', And(memDATA' != auxDATA', x' == True), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Or(n[1].data' == 1, n[1].data' == 2), Or(memDATA == 1, memDATA == 2), Or(memDATA' == 1, memDATA' == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[1].data == 1, n[1].data == 2), Or(n[2].data == 1, n[2].data == 2)]
unsat
c51_Crit1_1_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [VarExpr('memDATA'), VarExpr('auxDATA')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
current_inv: c51
val: C <class 'str'>
val: False <class 'bool'>
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [And(n[2].st == T, x == True), n[2].st' == C, x' == False, n[2].data' == memDATA, memDATA == memDATA', auxDATA == auxDATA', And(memDATA' != auxDATA', x' == True), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Or(n[2].data' == 1, n[2].data' == 2), Or(memDATA == 1, memDATA == 2), Or(memDATA' == 1, memDATA' == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[1].data == 1, n[1].data == 2), Or(n[2].data == 1, n[2].data == 2)]
unsat
c51_Crit1_1_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [VarExpr('auxDATA')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
current_inv: c51
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[1].st == E, n[1].st' == I, x' == True, memDATA' == n[1].data, auxDATA == auxDATA', And(memDATA' != auxDATA', x' == True), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Or(memDATA' == 1, memDATA' == 2), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
sat
解是：

[n[2].st = I,
 x = False,
 n[1].data = 1,
 n[2].data = 1,
 memDATA = 1,
 auxDATA' = 2,
 n[1].st' = I,
 n[1].st = E,
 auxDATA = 2,
 memDATA' = 1,
 x' = True]
invlist1: [OpExpr(=, n[1].st, E), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1), OpExpr(=, memDATA, 1), OpExpr(=, x, false)]
paraVars: [{'1': 'NODE'}, {'2': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA)), NegExpr(memDATA != auxDATA & x = true), NegExpr(n[2].st = C & n[1].st = C)]
set(self.enum_notEqulVars): {n[1].st}
set(self.enum_EqulVars): {n[2].st, auxDATA, n[1].st, n[1].st'}
self.enum_notEqulVars_map: {'n[1].st': ['C']}
1111: [n[1].st == E,
 n[1].st' == I,
 x' == True,
 memDATA' == n[1].data,
 auxDATA == auxDATA',
 And(memDATA' != auxDATA', x' == True),
 And(Implies(n[1].st == C, n[1].data == auxDATA),
     Implies(n[2].st == C, n[2].data == auxDATA)),
 Implies(memDATA != auxDATA, x != True),
 Implies(n[2].st == C, n[1].st != C),
 Or(memDATA' == 1, memDATA' == 2),
 Or(n[1].data == 1, n[1].data == 2),
 Or(auxDATA == 1, auxDATA == 2),
 Or(auxDATA' == 1, auxDATA' == 2),
 Or(n[2].data == 1, n[2].data == 2),
 Or(memDATA == 1, memDATA == 2)]
checkVars: []
solution: [OpExpr(=, n[1].st, E), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1), OpExpr(=, memDATA, 1), OpExpr(=, x, false)]
inv_list [OpExpr(=, n[1].st, E), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1), OpExpr(=, memDATA, 1), OpExpr(=, x, false)]
new_inv: invariant "c51_Crit1_1_Idle1"
   !(x = false & memDATA = 1 & n[2].data = 1 & n[2].st = I & auxDATA = 2 & n[1].data = 1 & n[1].st = E);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, E), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1), OpExpr(=, memDATA, 1)]
inv_list [OpExpr(=, n[1].st, E), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1), OpExpr(=, memDATA, 1)]
new_inv: invariant "c51_Crit1_1_Idle1"
   !(memDATA = 1 & n[2].data = 1 & n[2].st = I & auxDATA = 2 & n[1].data = 1 & n[1].st = E);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, E), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1)]
inv_list [OpExpr(=, n[1].st, E), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1)]
new_inv: invariant "c51_Crit1_1_Idle1"
   !(n[2].data = 1 & n[2].st = I & auxDATA = 2 & n[1].data = 1 & n[1].st = E);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, E), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I)]
inv_list [OpExpr(=, n[1].st, E), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I)]
new_inv: invariant "c51_Crit1_1_Idle1"
   !(n[2].st = I & auxDATA = 2 & n[1].data = 1 & n[1].st = E);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, E), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2)]
inv_list [OpExpr(=, n[1].st, E), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2)]
new_inv: invariant "c51_Crit1_1_Idle1"
   !(auxDATA = 2 & n[1].data = 1 & n[1].st = E);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, E), OpExpr(=, n[1].data, 1)]
inv_list [OpExpr(=, n[1].st, E), OpExpr(=, n[1].data, 1)]
new_inv: invariant "c51_Crit1_1_Idle1"
   !(n[1].data = 1 & n[1].st = E);
counter_ex: ['c51_Crit1_1_Idle1']
sublist: [OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 2)]
inv_list [OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 2)]
new_inv: invariant "c51_Crit1_1_Idle1"
   !(auxDATA = 2 & n[1].st = E);
counter_ex: ['c51_Crit1_1_Idle1']
sublist: [OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2)]
inv_list [OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2)]
new_inv: invariant "c51_Crit1_1_Idle1"
   !(auxDATA = 2 & n[1].data = 1);
counter_ex: ['c51_Crit1_1_Idle1']
self.aux_inv1: !(auxDATA = 2 & n[1].data = 1 & n[1].st = E)
self.aux_inv2: !(n[1].data != auxDATA & n[1].st = E)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C'], ['n[_].st = C', 'n[_].st = E']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}, ('n[_].st = C', 'n[_].st = E'): {}}
matches: {'n[1].data', 'n[1].st'}
var.keys(): 1
var.keys(): 2
var_list: []
Oplist: ['n[_].data != auxDATA', 'n[_].st = E']
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
add pattern: !(n[1].data != auxDATA & n[1].st = E)
inv_str:
 !(n[1].data != auxDATA & n[1].st = E)
;
c51_Crit1_1_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [VarExpr('auxDATA')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
current_inv: c51
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[2].st == E, n[2].st' == I, x' == True, memDATA' == n[2].data, auxDATA == auxDATA', And(memDATA' != auxDATA', x' == True), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(memDATA' == 1, memDATA' == 2), Or(n[2].data == 1, n[2].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[1].data == 1, n[1].data == 2), Or(memDATA == 1, memDATA == 2)]
sat
解是：

[auxDATA' = 1,
 n[1].data = 1,
 memDATA = 1,
 n[2].data = 2,
 n[1].st = I,
 x = True,
 memDATA' = 2,
 auxDATA = 1,
 x' = True,
 n[2].st' = I,
 n[2].st = E]
invlist1: [OpExpr(=, n[2].st, E), OpExpr(=, n[2].data, 2), OpExpr(=, auxDATA, 1), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, memDATA, 1), OpExpr(=, x, true)]
paraVars: [{'2': 'NODE'}, {'1': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA)), NegExpr(memDATA != auxDATA & x = true), NegExpr(n[2].st = C & n[1].st = C), NegExpr(n[1].data != auxDATA & n[1].st = E)]
set(self.enum_notEqulVars): {n[1].st}
set(self.enum_EqulVars): {n[2].st, n[2].st', n[1].st, auxDATA}
self.enum_notEqulVars_map: {'n[1].st': ['C', 'E']}
1111: [n[2].st == E,
 n[2].st' == I,
 x' == True,
 memDATA' == n[2].data,
 auxDATA == auxDATA',
 And(memDATA' != auxDATA', x' == True),
 And(Implies(n[1].st == C, n[1].data == auxDATA),
     Implies(n[2].st == C, n[2].data == auxDATA)),
 Implies(memDATA != auxDATA, x != True),
 Implies(n[2].st == C, n[1].st != C),
 Implies(n[1].data != auxDATA, n[1].st != E),
 Or(memDATA' == 1, memDATA' == 2),
 Or(n[2].data == 1, n[2].data == 2),
 Or(auxDATA == 1, auxDATA == 2),
 Or(auxDATA' == 1, auxDATA' == 2),
 Or(n[1].data == 1, n[1].data == 2),
 Or(memDATA == 1, memDATA == 2)]
checkVars: []
solution: [OpExpr(=, n[2].st, E), OpExpr(=, n[2].data, 2), OpExpr(=, auxDATA, 1), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, memDATA, 1), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[2].st, E), OpExpr(=, n[2].data, 2), OpExpr(=, auxDATA, 1), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, memDATA, 1), OpExpr(=, x, true)]
new_inv: invariant "c51_Crit1_1_Idle2"
   !(x = true & memDATA = 1 & n[1].data = 1 & n[1].st = I & auxDATA = 1 & n[2].data = 2 & n[2].st = E);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, E), OpExpr(=, n[2].data, 2), OpExpr(=, auxDATA, 1), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, memDATA, 1)]
inv_list [OpExpr(=, n[2].st, E), OpExpr(=, n[2].data, 2), OpExpr(=, auxDATA, 1), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, memDATA, 1)]
new_inv: invariant "c51_Crit1_1_Idle2"
   !(memDATA = 1 & n[1].data = 1 & n[1].st = I & auxDATA = 1 & n[2].data = 2 & n[2].st = E);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, E), OpExpr(=, n[2].data, 2), OpExpr(=, auxDATA, 1), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1)]
inv_list [OpExpr(=, n[2].st, E), OpExpr(=, n[2].data, 2), OpExpr(=, auxDATA, 1), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1)]
new_inv: invariant "c51_Crit1_1_Idle2"
   !(n[1].data = 1 & n[1].st = I & auxDATA = 1 & n[2].data = 2 & n[2].st = E);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, E), OpExpr(=, n[2].data, 2), OpExpr(=, auxDATA, 1), OpExpr(=, n[1].st, I)]
inv_list [OpExpr(=, n[2].st, E), OpExpr(=, n[2].data, 2), OpExpr(=, auxDATA, 1), OpExpr(=, n[1].st, I)]
new_inv: invariant "c51_Crit1_1_Idle2"
   !(n[1].st = I & auxDATA = 1 & n[2].data = 2 & n[2].st = E);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, E), OpExpr(=, n[2].data, 2), OpExpr(=, auxDATA, 1)]
inv_list [OpExpr(=, n[2].st, E), OpExpr(=, n[2].data, 2), OpExpr(=, auxDATA, 1)]
new_inv: invariant "c51_Crit1_1_Idle2"
   !(auxDATA = 1 & n[2].data = 2 & n[2].st = E);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, E), OpExpr(=, n[2].data, 2)]
inv_list [OpExpr(=, n[2].st, E), OpExpr(=, n[2].data, 2)]
new_inv: invariant "c51_Crit1_1_Idle2"
   !(n[2].data = 2 & n[2].st = E);
counter_ex: ['c51_Crit1_1_Idle2']
sublist: [OpExpr(=, n[2].st, E), OpExpr(=, auxDATA, 1)]
inv_list [OpExpr(=, n[2].st, E), OpExpr(=, auxDATA, 1)]
new_inv: invariant "c51_Crit1_1_Idle2"
   !(auxDATA = 1 & n[2].st = E);
counter_ex: ['c51_Crit1_1_Idle2']
sublist: [OpExpr(=, n[2].data, 2), OpExpr(=, auxDATA, 1)]
inv_list [OpExpr(=, n[2].data, 2), OpExpr(=, auxDATA, 1)]
new_inv: invariant "c51_Crit1_1_Idle2"
   !(auxDATA = 1 & n[2].data = 2);
counter_ex: ['c51_Crit1_1_Idle2']
self.aux_inv1: !(auxDATA = 1 & n[2].data = 2 & n[2].st = E)
self.aux_inv2: !(n[2].data != auxDATA & n[2].st = E)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C'], ['n[_].st = C', 'n[_].st = E'], ['n[_].data != auxDATA', 'n[_].st = E']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}, ('n[_].st = C', 'n[_].st = E'): {}, ('n[_].data != auxDATA', 'n[_].st = E'): {}}
matches: {'n[2].data', 'n[2].st'}
var.keys(): 2
var.keys(): 1
var_list: []
Oplist: ['n[_].data != auxDATA', 'n[_].st = E']
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
exist self.aux_inv: !(n[2].data != auxDATA & n[2].st = E)
c51_Crit1_1_Store1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [VarExpr('memDATA'), VarExpr('x')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
current_inv: c51
val: 1 <class 'int'>
val: 1 <class 'int'>
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [n[1].st == C, auxDATA' == 1, n[1].data' == 1, memDATA == memDATA', x == x', And(memDATA' != auxDATA', x' == True), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(auxDATA' == 1, auxDATA' == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(memDATA == 1, memDATA == 2), Or(memDATA' == 1, memDATA' == 2), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2)]
sat
解是：

[n[2].st = I,
 n[2].data = 1,
 auxDATA' = 1,
 n[1].st = C,
 memDATA = 2,
 n[1].data = 2,
 x = True,
 n[1].data' = 1,
 memDATA' = 2,
 auxDATA = 2,
 x' = True]
invlist1: [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1)]
paraVars: [{'1': 'NODE'}, {'2': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA)), NegExpr(memDATA != auxDATA & x = true), NegExpr(n[2].st = C & n[1].st = C), NegExpr(n[1].data != auxDATA & n[1].st = E)]
set(self.enum_notEqulVars): {n[1].st}
set(self.enum_EqulVars): {n[2].st, x, memDATA, n[1].st}
self.enum_notEqulVars_map: {'n[1].st': ['C', 'E']}
1111: [n[1].st == C,
 auxDATA' == 1,
 n[1].data' == 1,
 memDATA == memDATA',
 x == x',
 And(memDATA' != auxDATA', x' == True),
 And(Implies(n[1].st == C, n[1].data == auxDATA),
     Implies(n[2].st == C, n[2].data == auxDATA)),
 Implies(memDATA != auxDATA, x != True),
 Implies(n[2].st == C, n[1].st != C),
 Implies(n[1].data != auxDATA, n[1].st != E),
 Or(auxDATA' == 1, auxDATA' == 2),
 Or(n[1].data' == 1, n[1].data' == 2),
 Or(memDATA == 1, memDATA == 2),
 Or(memDATA' == 1, memDATA' == 2),
 Or(n[1].data == 1, n[1].data == 2),
 Or(auxDATA == 1, auxDATA == 2),
 Or(n[2].data == 1, n[2].data == 2)]
checkVars: []
solution: [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1)]
new_inv: invariant "c51_Crit1_1_Store1"
   !(n[2].data = 1 & n[2].st = I & auxDATA = 2 & n[1].data = 2 & x = true & memDATA = 2 & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].st, I)]
new_inv: invariant "c51_Crit1_1_Store1"
   !(n[2].st = I & auxDATA = 2 & n[1].data = 2 & x = true & memDATA = 2 & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 2)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 2)]
new_inv: invariant "c51_Crit1_1_Store1"
   !(auxDATA = 2 & n[1].data = 2 & x = true & memDATA = 2 & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].data, 2)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].data, 2)]
new_inv: invariant "c51_Crit1_1_Store1"
   !(n[1].data = 2 & x = true & memDATA = 2 & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true)]
new_inv: invariant "c51_Crit1_1_Store1"
   !(x = true & memDATA = 2 & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 2)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 2)]
new_inv: invariant "c51_Crit1_1_Store1"
   !(memDATA = 2 & n[1].st = C);
counter_ex: ['c51_Crit1_1_Store1']
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, x, true)]
new_inv: invariant "c51_Crit1_1_Store1"
   !(x = true & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C)]
inv_list [OpExpr(=, n[1].st, C)]
new_inv: invariant "c51_Crit1_1_Store1"
   !(n[1].st = C);
counter_ex: ['c51_Crit1_1_Store1']
sublist: [OpExpr(=, x, true)]
inv_list [OpExpr(=, x, true)]
new_inv: invariant "c51_Crit1_1_Store1"
   !(x = true);
counter_ex: ['c51_Crit1_1_Store1']
self.aux_inv1: !(x = true & n[1].st = C)
self.aux_inv2: !(x = true & n[1].st = C)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C'], ['n[_].st = C', 'n[_].st = E'], ['n[_].data != auxDATA', 'n[_].st = E']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}, ('n[_].st = C', 'n[_].st = E'): {}, ('n[_].data != auxDATA', 'n[_].st = E'): {}}
matches: {'n[1].st'}
var.keys(): 1
var.keys(): 2
var_list: []
Oplist: ['x = true', 'n[_].st = C']
var出现次数： {}
{}
exist self.aux_inv: !(x = true & n[1].st = C)
c51_Crit1_1_Store2 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [VarExpr('memDATA'), VarExpr('x')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
current_inv: c51
val: 2 <class 'int'>
val: 2 <class 'int'>
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [n[1].st == C, auxDATA' == 2, n[1].data' == 2, memDATA == memDATA', x == x', And(memDATA' != auxDATA', x' == True), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(auxDATA' == 1, auxDATA' == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(memDATA == 1, memDATA == 2), Or(memDATA' == 1, memDATA' == 2), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2)]
sat
解是：

[n[2].st = I,
 n[2].data = 1,
 auxDATA' = 2,
 n[1].st = C,
 memDATA = 1,
 n[1].data = 1,
 x = True,
 n[1].data' = 2,
 memDATA' = 1,
 auxDATA = 1,
 x' = True]
invlist1: [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1)]
paraVars: [{'1': 'NODE'}, {'2': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA)), NegExpr(memDATA != auxDATA & x = true), NegExpr(n[2].st = C & n[1].st = C), NegExpr(n[1].data != auxDATA & n[1].st = E)]
set(self.enum_notEqulVars): {n[1].st}
set(self.enum_EqulVars): {n[2].st, x, memDATA, n[1].st}
self.enum_notEqulVars_map: {'n[1].st': ['C', 'E']}
1111: [n[1].st == C,
 auxDATA' == 2,
 n[1].data' == 2,
 memDATA == memDATA',
 x == x',
 And(memDATA' != auxDATA', x' == True),
 And(Implies(n[1].st == C, n[1].data == auxDATA),
     Implies(n[2].st == C, n[2].data == auxDATA)),
 Implies(memDATA != auxDATA, x != True),
 Implies(n[2].st == C, n[1].st != C),
 Implies(n[1].data != auxDATA, n[1].st != E),
 Or(auxDATA' == 1, auxDATA' == 2),
 Or(n[1].data' == 1, n[1].data' == 2),
 Or(memDATA == 1, memDATA == 2),
 Or(memDATA' == 1, memDATA' == 2),
 Or(n[1].data == 1, n[1].data == 2),
 Or(auxDATA == 1, auxDATA == 2),
 Or(n[2].data == 1, n[2].data == 2)]
checkVars: []
solution: [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].st, I), OpExpr(=, n[2].data, 1)]
new_inv: invariant "c51_Crit1_1_Store2"
   !(n[2].data = 1 & n[2].st = I & auxDATA = 1 & n[1].data = 1 & x = true & memDATA = 1 & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].st, I)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].st, I)]
new_inv: invariant "c51_Crit1_1_Store2"
   !(n[2].st = I & auxDATA = 1 & n[1].data = 1 & x = true & memDATA = 1 & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1)]
new_inv: invariant "c51_Crit1_1_Store2"
   !(auxDATA = 1 & n[1].data = 1 & x = true & memDATA = 1 & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].data, 1)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].data, 1)]
new_inv: invariant "c51_Crit1_1_Store2"
   !(n[1].data = 1 & x = true & memDATA = 1 & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true)]
new_inv: invariant "c51_Crit1_1_Store2"
   !(x = true & memDATA = 1 & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 1)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, memDATA, 1)]
new_inv: invariant "c51_Crit1_1_Store2"
   !(memDATA = 1 & n[1].st = C);
counter_ex: ['c51_Crit1_1_Store2']
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, x, true)]
new_inv: invariant "c51_Crit1_1_Store2"
   !(x = true & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C)]
inv_list [OpExpr(=, n[1].st, C)]
new_inv: invariant "c51_Crit1_1_Store2"
   !(n[1].st = C);
counter_ex: ['c51_Crit1_1_Store2']
sublist: [OpExpr(=, x, true)]
inv_list [OpExpr(=, x, true)]
new_inv: invariant "c51_Crit1_1_Store2"
   !(x = true);
counter_ex: ['c51_Crit1_1_Store2']
self.aux_inv1: !(x = true & n[1].st = C)
self.aux_inv2: !(x = true & n[1].st = C)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C'], ['n[_].st = C', 'n[_].st = E'], ['n[_].data != auxDATA', 'n[_].st = E']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}, ('n[_].st = C', 'n[_].st = E'): {}, ('n[_].data != auxDATA', 'n[_].st = E'): {}}
matches: {'n[1].st'}
var.keys(): 1
var.keys(): 2
var_list: []
Oplist: ['x = true', 'n[_].st = C']
var出现次数： {}
{}
exist self.aux_inv: !(x = true & n[1].st = C)
c51_Crit1_1_Store3 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [VarExpr('memDATA'), VarExpr('x')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
current_inv: c51
val: 1 <class 'int'>
val: 1 <class 'int'>
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [n[2].st == C, auxDATA' == 1, n[2].data' == 1, memDATA == memDATA', x == x', And(memDATA' != auxDATA', x' == True), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data' == 1, n[2].data' == 2), Or(memDATA == 1, memDATA == 2), Or(memDATA' == 1, memDATA' == 2), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2)]
sat
解是：

[n[1].data = 1,
 n[1].st = I,
 auxDATA' = 1,
 memDATA = 2,
 n[2].st = C,
 x = True,
 n[2].data = 2,
 n[2].data' = 1,
 memDATA' = 2,
 auxDATA = 2,
 x' = True]
invlist1: [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].data, 2)]
paraVars: [{'2': 'NODE'}, {'1': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA)), NegExpr(memDATA != auxDATA & x = true), NegExpr(n[2].st = C & n[1].st = C), NegExpr(n[1].data != auxDATA & n[1].st = E)]
set(self.enum_notEqulVars): {n[1].st}
set(self.enum_EqulVars): {n[2].st, x, memDATA, n[1].st}
self.enum_notEqulVars_map: {'n[1].st': ['C', 'E']}
1111: [n[2].st == C,
 auxDATA' == 1,
 n[2].data' == 1,
 memDATA == memDATA',
 x == x',
 And(memDATA' != auxDATA', x' == True),
 And(Implies(n[1].st == C, n[1].data == auxDATA),
     Implies(n[2].st == C, n[2].data == auxDATA)),
 Implies(memDATA != auxDATA, x != True),
 Implies(n[2].st == C, n[1].st != C),
 Implies(n[1].data != auxDATA, n[1].st != E),
 Or(auxDATA' == 1, auxDATA' == 2),
 Or(n[2].data' == 1, n[2].data' == 2),
 Or(memDATA == 1, memDATA == 2),
 Or(memDATA' == 1, memDATA' == 2),
 Or(n[1].data == 1, n[1].data == 2),
 Or(auxDATA == 1, auxDATA == 2),
 Or(n[2].data == 1, n[2].data == 2)]
checkVars: []
solution: [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].data, 2)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].data, 2)]
new_inv: invariant "c51_Crit1_1_Store3"
   !(n[2].data = 2 & auxDATA = 2 & n[1].data = 1 & n[1].st = I & x = true & memDATA = 2 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 2)]
new_inv: invariant "c51_Crit1_1_Store3"
   !(auxDATA = 2 & n[1].data = 1 & n[1].st = I & x = true & memDATA = 2 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1)]
new_inv: invariant "c51_Crit1_1_Store3"
   !(n[1].data = 1 & n[1].st = I & x = true & memDATA = 2 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].st, I)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true), OpExpr(=, n[1].st, I)]
new_inv: invariant "c51_Crit1_1_Store3"
   !(n[1].st = I & x = true & memDATA = 2 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 2), OpExpr(=, x, true)]
new_inv: invariant "c51_Crit1_1_Store3"
   !(x = true & memDATA = 2 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 2)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 2)]
new_inv: invariant "c51_Crit1_1_Store3"
   !(memDATA = 2 & n[2].st = C);
counter_ex: ['c51_Crit1_1_Store3']
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, x, true)]
new_inv: invariant "c51_Crit1_1_Store3"
   !(x = true & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[2].st, C)]
new_inv: invariant "c51_Crit1_1_Store3"
   !(n[2].st = C);
counter_ex: ['c51_Crit1_1_Store3']
sublist: [OpExpr(=, x, true)]
inv_list [OpExpr(=, x, true)]
new_inv: invariant "c51_Crit1_1_Store3"
   !(x = true);
counter_ex: ['c51_Crit1_1_Store3']
self.aux_inv1: !(x = true & n[2].st = C)
self.aux_inv2: !(x = true & n[2].st = C)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C'], ['n[_].st = C', 'n[_].st = E'], ['n[_].data != auxDATA', 'n[_].st = E']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}, ('n[_].st = C', 'n[_].st = E'): {}, ('n[_].data != auxDATA', 'n[_].st = E'): {}}
matches: {'n[2].st'}
var.keys(): 2
var.keys(): 1
var_list: []
Oplist: ['x = true', 'n[_].st = C']
var出现次数： {}
{}
exist self.aux_inv: !(x = true & n[2].st = C)
c51_Crit1_1_Store4 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [VarExpr('memDATA'), VarExpr('x')], '!inv': NegExpr(!(memDATA != auxDATA & x = true))}
current_inv: c51
val: 2 <class 'int'>
val: 2 <class 'int'>
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [n[2].st == C, auxDATA' == 2, n[2].data' == 2, memDATA == memDATA', x == x', And(memDATA' != auxDATA', x' == True), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data' == 1, n[2].data' == 2), Or(memDATA == 1, memDATA == 2), Or(memDATA' == 1, memDATA' == 2), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2)]
sat
解是：

[n[1].data = 1,
 n[1].st = I,
 auxDATA' = 2,
 memDATA = 1,
 n[2].st = C,
 x = True,
 n[2].data = 1,
 n[2].data' = 2,
 memDATA' = 1,
 auxDATA = 1,
 x' = True]
invlist1: [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 1)]
paraVars: [{'2': 'NODE'}, {'1': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA)), NegExpr(memDATA != auxDATA & x = true), NegExpr(n[2].st = C & n[1].st = C), NegExpr(n[1].data != auxDATA & n[1].st = E)]
set(self.enum_notEqulVars): {n[1].st}
set(self.enum_EqulVars): {n[2].st, x, memDATA, n[1].st}
self.enum_notEqulVars_map: {'n[1].st': ['C', 'E']}
1111: [n[2].st == C,
 auxDATA' == 2,
 n[2].data' == 2,
 memDATA == memDATA',
 x == x',
 And(memDATA' != auxDATA', x' == True),
 And(Implies(n[1].st == C, n[1].data == auxDATA),
     Implies(n[2].st == C, n[2].data == auxDATA)),
 Implies(memDATA != auxDATA, x != True),
 Implies(n[2].st == C, n[1].st != C),
 Implies(n[1].data != auxDATA, n[1].st != E),
 Or(auxDATA' == 1, auxDATA' == 2),
 Or(n[2].data' == 1, n[2].data' == 2),
 Or(memDATA == 1, memDATA == 2),
 Or(memDATA' == 1, memDATA' == 2),
 Or(n[1].data == 1, n[1].data == 2),
 Or(auxDATA == 1, auxDATA == 2),
 Or(n[2].data == 1, n[2].data == 2)]
checkVars: []
solution: [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 1)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 1)]
new_inv: invariant "c51_Crit1_1_Store4"
   !(n[2].data = 1 & auxDATA = 1 & n[1].data = 1 & n[1].st = I & x = true & memDATA = 1 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1)]
new_inv: invariant "c51_Crit1_1_Store4"
   !(auxDATA = 1 & n[1].data = 1 & n[1].st = I & x = true & memDATA = 1 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].st, I), OpExpr(=, n[1].data, 1)]
new_inv: invariant "c51_Crit1_1_Store4"
   !(n[1].data = 1 & n[1].st = I & x = true & memDATA = 1 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].st, I)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true), OpExpr(=, n[1].st, I)]
new_inv: invariant "c51_Crit1_1_Store4"
   !(n[1].st = I & x = true & memDATA = 1 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 1), OpExpr(=, x, true)]
new_inv: invariant "c51_Crit1_1_Store4"
   !(x = true & memDATA = 1 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 1)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, memDATA, 1)]
new_inv: invariant "c51_Crit1_1_Store4"
   !(memDATA = 1 & n[2].st = C);
counter_ex: ['c51_Crit1_1_Store4']
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, x, true)]
new_inv: invariant "c51_Crit1_1_Store4"
   !(x = true & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[2].st, C)]
new_inv: invariant "c51_Crit1_1_Store4"
   !(n[2].st = C);
counter_ex: ['c51_Crit1_1_Store4']
sublist: [OpExpr(=, x, true)]
inv_list [OpExpr(=, x, true)]
new_inv: invariant "c51_Crit1_1_Store4"
   !(x = true);
counter_ex: ['c51_Crit1_1_Store4']
self.aux_inv1: !(x = true & n[2].st = C)
self.aux_inv2: !(x = true & n[2].st = C)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C'], ['n[_].st = C', 'n[_].st = E'], ['n[_].data != auxDATA', 'n[_].st = E']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}, ('n[_].st = C', 'n[_].st = E'): {}, ('n[_].data != auxDATA', 'n[_].st = E'): {}}
matches: {'n[2].st'}
var.keys(): 2
var.keys(): 1
var_list: []
Oplist: ['x = true', 'n[_].st = C']
var出现次数： {}
{}
exist self.aux_inv: !(x = true & n[2].st = C)
list0: {'c51_Store1_1': NegExpr(n[2].st = C & n[1].st = C), 'coherence_Crit1_1_Idle1_1': NegExpr(n[2].st = C & n[1].st = E), 'c51_Crit1_1_Idle1_1': NegExpr(n[1].data != auxDATA & n[1].st = E)}
new_inv: !(n[2].st = C & n[1].st = C)
c51_Store1_1_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
c51_Store1_1_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
c51_Store1_1_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
c51_Store1_1_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
c51_Store1_1_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
c51_Store1_1_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
c51_Store1_1_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
c51_Store1_1_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
c51_Store1_1_Store1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
c51_Store1_1_Store2 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
c51_Store1_1_Store3 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
c51_Store1_1_Store4 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
booleanExpr_list: [VarExpr('x')]
scalarsetVars: [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('auxDATA')]
list1: {'coherence_Crit1_1_Idle1_1': NegExpr(n[2].st = C & n[1].st = E), 'c51_Crit1_1_Idle1_1': NegExpr(n[1].data != auxDATA & n[1].st = E)}
c51_Store1_1_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
current_inv: c51
val: T <class 'str'>
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[1].st == I, n[1].st' == T, n[2].st == n[2].st', And(n[2].st' == C, n[1].st' == C), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Store1_1_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
current_inv: c51
val: T <class 'str'>
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[2].st == I, n[2].st' == T, n[1].st == n[1].st', And(n[2].st' == C, n[1].st' == C), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Store1_1_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
current_inv: c51
val: C <class 'str'>
val: False <class 'bool'>
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [And(n[1].st == T, x == True), n[1].st' == C, x' == False, n[1].data' == memDATA, n[2].st == n[2].st', And(n[2].st' == C, n[1].st' == C), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(n[1].data' == 1, n[1].data' == 2), Or(memDATA == 1, memDATA == 2), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2)]
sat
解是：

[n[1].data = 2,
 n[2].data = 1,
 auxDATA = 1,
 n[1].st = T,
 memDATA = 1,
 n[2].st' = C,
 n[2].st = C,
 n[1].st' = C,
 x = True,
 n[1].data' = 1,
 x' = False]
invlist1: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 1)]
paraVars: [{'1': 'NODE'}, {'2': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA)), NegExpr(memDATA != auxDATA & x = true), NegExpr(n[2].st = C & n[1].st = C), NegExpr(n[1].data != auxDATA & n[1].st = E)]
set(self.enum_notEqulVars): {n[1].st}
set(self.enum_EqulVars): {n[2].st, n[2].st', n[1].st, n[1].st'}
self.enum_notEqulVars_map: {'n[1].st': ['C', 'E']}
1111: [And(n[1].st == T, x == True),
 n[1].st' == C,
 x' == False,
 n[1].data' == memDATA,
 n[2].st == n[2].st',
 And(n[2].st' == C, n[1].st' == C),
 And(Implies(n[1].st == C, n[1].data == auxDATA),
     Implies(n[2].st == C, n[2].data == auxDATA)),
 Implies(memDATA != auxDATA, x != True),
 Implies(n[2].st == C, n[1].st != C),
 Implies(n[1].data != auxDATA, n[1].st != E),
 Or(n[1].data' == 1, n[1].data' == 2),
 Or(memDATA == 1, memDATA == 2),
 Or(n[1].data == 1, n[1].data == 2),
 Or(auxDATA == 1, auxDATA == 2),
 Or(n[2].data == 1, n[2].data == 2)]
checkVars: []
solution: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 1)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 1)]
new_inv: invariant "c51_Store1_1_Crit1"
   !(n[2].data = 1 & auxDATA = 1 & n[1].data = 2 & n[2].st = C & memDATA = 1 & x = true & n[1].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 1)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, auxDATA, 1)]
new_inv: invariant "c51_Store1_1_Crit1"
   !(auxDATA = 1 & n[1].data = 2 & n[2].st = C & memDATA = 1 & x = true & n[1].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2)]
new_inv: invariant "c51_Store1_1_Crit1"
   !(n[1].data = 2 & n[2].st = C & memDATA = 1 & x = true & n[1].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[2].st, C)]
new_inv: invariant "c51_Store1_1_Crit1"
   !(n[2].st = C & memDATA = 1 & x = true & n[1].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1)]
new_inv: invariant "c51_Store1_1_Crit1"
   !(memDATA = 1 & x = true & n[1].st = T);
counter_ex: ['c51_Store1_1_Crit1']
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true), OpExpr(=, n[2].st, C)]
new_inv: invariant "c51_Store1_1_Crit1"
   !(n[2].st = C & x = true & n[1].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, x, true)]
new_inv: invariant "c51_Store1_1_Crit1"
   !(x = true & n[1].st = T);
counter_ex: ['c51_Store1_1_Crit1']
sublist: [OpExpr(=, n[1].st, T), OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[1].st, T), OpExpr(=, n[2].st, C)]
new_inv: invariant "c51_Store1_1_Crit1"
   !(n[2].st = C & n[1].st = T);
counter_ex: ['c51_Store1_1_Crit1']
sublist: [OpExpr(=, x, true), OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, x, true), OpExpr(=, n[2].st, C)]
new_inv: invariant "c51_Store1_1_Crit1"
   !(n[2].st = C & x = true);
No cti found. The invariants are OK.
sublist: [OpExpr(=, x, true)]
inv_list [OpExpr(=, x, true)]
new_inv: invariant "c51_Store1_1_Crit1"
   !(x = true);
counter_ex: ['c51_Store1_1_Crit1']
sublist: [OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[2].st, C)]
new_inv: invariant "c51_Store1_1_Crit1"
   !(n[2].st = C);
counter_ex: ['c51_Store1_1_Crit1']
self.aux_inv1: !(n[2].st = C & x = true)
self.aux_inv2: !(n[2].st = C & x = true)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C'], ['n[_].st = C', 'n[_].st = E'], ['n[_].data != auxDATA', 'n[_].st = E']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}, ('n[_].st = C', 'n[_].st = E'): {}, ('n[_].data != auxDATA', 'n[_].st = E'): {}}
matches: {'n[2].st'}
var.keys(): 1
var.keys(): 2
var_list: []
Oplist: ['n[_].st = C', 'x = true']
var出现次数： {}
{}
exist self.aux_inv: !(n[2].st = C & x = true)
c51_Store1_1_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
current_inv: c51
val: C <class 'str'>
val: False <class 'bool'>
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [And(n[2].st == T, x == True), n[2].st' == C, x' == False, n[2].data' == memDATA, n[1].st == n[1].st', And(n[2].st' == C, n[1].st' == C), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(n[2].data' == 1, n[2].data' == 2), Or(memDATA == 1, memDATA == 2), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2)]
sat
解是：

[n[1].data = 1,
 n[2].data = 2,
 auxDATA = 1,
 n[1].st = C,
 memDATA = 1,
 n[2].st' = C,
 n[2].st = T,
 n[1].st' = C,
 x = True,
 n[2].data' = 1,
 x' = False]
invlist1: [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[1].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 2)]
paraVars: [{'2': 'NODE'}, {'1': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA)), NegExpr(memDATA != auxDATA & x = true), NegExpr(n[2].st = C & n[1].st = C), NegExpr(n[1].data != auxDATA & n[1].st = E)]
set(self.enum_notEqulVars): {n[1].st}
set(self.enum_EqulVars): {n[2].st, n[2].st', n[1].st, n[1].st'}
self.enum_notEqulVars_map: {'n[1].st': ['C', 'E']}
1111: [And(n[2].st == T, x == True),
 n[2].st' == C,
 x' == False,
 n[2].data' == memDATA,
 n[1].st == n[1].st',
 And(n[2].st' == C, n[1].st' == C),
 And(Implies(n[1].st == C, n[1].data == auxDATA),
     Implies(n[2].st == C, n[2].data == auxDATA)),
 Implies(memDATA != auxDATA, x != True),
 Implies(n[2].st == C, n[1].st != C),
 Implies(n[1].data != auxDATA, n[1].st != E),
 Or(n[2].data' == 1, n[2].data' == 2),
 Or(memDATA == 1, memDATA == 2),
 Or(n[1].data == 1, n[1].data == 2),
 Or(auxDATA == 1, auxDATA == 2),
 Or(n[2].data == 1, n[2].data == 2)]
checkVars: []
solution: [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[1].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 2)]
inv_list [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[1].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 2)]
new_inv: invariant "c51_Store1_1_Crit2"
   !(n[2].data = 2 & auxDATA = 1 & n[1].data = 1 & n[1].st = C & memDATA = 1 & x = true & n[2].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[1].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1)]
inv_list [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[1].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, auxDATA, 1)]
new_inv: invariant "c51_Store1_1_Crit2"
   !(auxDATA = 1 & n[1].data = 1 & n[1].st = C & memDATA = 1 & x = true & n[2].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[1].st, C), OpExpr(=, n[1].data, 1)]
inv_list [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[1].st, C), OpExpr(=, n[1].data, 1)]
new_inv: invariant "c51_Store1_1_Crit2"
   !(n[1].data = 1 & n[1].st = C & memDATA = 1 & x = true & n[2].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[1].st, C)]
inv_list [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[1].st, C)]
new_inv: invariant "c51_Store1_1_Crit2"
   !(n[1].st = C & memDATA = 1 & x = true & n[2].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1)]
inv_list [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1)]
new_inv: invariant "c51_Store1_1_Crit2"
   !(memDATA = 1 & x = true & n[2].st = T);
counter_ex: ['c51_Store1_1_Crit2']
sublist: [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, n[1].st, C)]
inv_list [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, n[1].st, C)]
new_inv: invariant "c51_Store1_1_Crit2"
   !(n[1].st = C & x = true & n[2].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, T), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[2].st, T), OpExpr(=, x, true)]
new_inv: invariant "c51_Store1_1_Crit2"
   !(x = true & n[2].st = T);
counter_ex: ['c51_Store1_1_Crit2']
sublist: [OpExpr(=, n[2].st, T), OpExpr(=, n[1].st, C)]
inv_list [OpExpr(=, n[2].st, T), OpExpr(=, n[1].st, C)]
new_inv: invariant "c51_Store1_1_Crit2"
   !(n[1].st = C & n[2].st = T);
counter_ex: ['c51_Store1_1_Crit2']
sublist: [OpExpr(=, x, true), OpExpr(=, n[1].st, C)]
inv_list [OpExpr(=, x, true), OpExpr(=, n[1].st, C)]
new_inv: invariant "c51_Store1_1_Crit2"
   !(n[1].st = C & x = true);
No cti found. The invariants are OK.
sublist: [OpExpr(=, x, true)]
inv_list [OpExpr(=, x, true)]
new_inv: invariant "c51_Store1_1_Crit2"
   !(x = true);
counter_ex: ['c51_Store1_1_Crit2']
sublist: [OpExpr(=, n[1].st, C)]
inv_list [OpExpr(=, n[1].st, C)]
new_inv: invariant "c51_Store1_1_Crit2"
   !(n[1].st = C);
counter_ex: ['c51_Store1_1_Crit2']
self.aux_inv1: !(n[1].st = C & x = true)
self.aux_inv2: !(n[1].st = C & x = true)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C'], ['n[_].st = C', 'n[_].st = E'], ['n[_].data != auxDATA', 'n[_].st = E']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}, ('n[_].st = C', 'n[_].st = E'): {}, ('n[_].data != auxDATA', 'n[_].st = E'): {}}
matches: {'n[1].st'}
var.keys(): 2
var.keys(): 1
var_list: []
Oplist: ['n[_].st = C', 'x = true']
var出现次数： {}
{}
exist self.aux_inv: !(n[1].st = C & x = true)
c51_Store1_1_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
current_inv: c51
val: E <class 'str'>
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[1].st == C, n[1].st' == E, n[2].st == n[2].st', And(n[2].st' == C, n[1].st' == C), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Store1_1_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
current_inv: c51
val: E <class 'str'>
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[2].st == C, n[2].st' == E, n[1].st == n[1].st', And(n[2].st' == C, n[1].st' == C), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Store1_1_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
current_inv: c51
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[1].st == E, n[1].st' == I, x' == True, memDATA' == n[1].data, n[2].st == n[2].st', And(n[2].st' == C, n[1].st' == C), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(memDATA' == 1, memDATA' == 2), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Store1_1_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = C))}
current_inv: c51
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[2].st == E, n[2].st' == I, x' == True, memDATA' == n[2].data, n[1].st == n[1].st', And(n[2].st' == C, n[1].st' == C), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(memDATA' == 1, memDATA' == 2), Or(n[2].data == 1, n[2].data == 2), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(memDATA == 1, memDATA == 2)]
unsat
list0: {'coherence_Crit1_1_Idle1_1': NegExpr(n[2].st = C & n[1].st = E), 'c51_Crit1_1_Idle1_1': NegExpr(n[1].data != auxDATA & n[1].st = E)}
new_inv: !(n[2].st = C & n[1].st = E)
coherence_Crit1_1_Idle1_1_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
coherence_Crit1_1_Idle1_1_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
coherence_Crit1_1_Idle1_1_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
coherence_Crit1_1_Idle1_1_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
coherence_Crit1_1_Idle1_1_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
coherence_Crit1_1_Idle1_1_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
coherence_Crit1_1_Idle1_1_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
coherence_Crit1_1_Idle1_1_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
coherence_Crit1_1_Idle1_1_Store1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
coherence_Crit1_1_Idle1_1_Store2 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
coherence_Crit1_1_Idle1_1_Store3 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
coherence_Crit1_1_Idle1_1_Store4 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
booleanExpr_list: [VarExpr('x')]
scalarsetVars: [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('auxDATA')]
list1: {'c51_Crit1_1_Idle1_1': NegExpr(n[1].data != auxDATA & n[1].st = E)}
coherence_Crit1_1_Idle1_1_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
current_inv: coherence
val: T <class 'str'>
6. F: [n[1].st == I, n[1].st' == T, n[2].st == n[2].st', And(n[2].st' == C, n[1].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E)]
unsat
coherence_Crit1_1_Idle1_1_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
current_inv: coherence
val: T <class 'str'>
6. F: [n[2].st == I, n[2].st' == T, n[1].st == n[1].st', And(n[2].st' == C, n[1].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E)]
unsat
coherence_Crit1_1_Idle1_1_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
current_inv: coherence
val: C <class 'str'>
val: False <class 'bool'>
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [And(n[1].st == T, x == True), n[1].st' == C, x' == False, n[1].data' == memDATA, n[2].st == n[2].st', And(n[2].st' == C, n[1].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Or(n[1].data' == 1, n[1].data' == 2), Or(memDATA == 1, memDATA == 2)]
unsat
coherence_Crit1_1_Idle1_1_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
current_inv: coherence
val: C <class 'str'>
val: False <class 'bool'>
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [And(n[2].st == T, x == True), n[2].st' == C, x' == False, n[2].data' == memDATA, n[1].st == n[1].st', And(n[2].st' == C, n[1].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Or(n[2].data' == 1, n[2].data' == 2), Or(memDATA == 1, memDATA == 2)]
sat
解是：

[memDATA = 1,
 n[1].st' = E,
 n[1].st = E,
 x = True,
 n[2].data' = 1,
 x' = False,
 n[2].st' = C,
 n[2].st = T]
invlist1: [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, memDATA, 1), OpExpr(=, n[1].st, E)]
invlist2: [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, n[1].st, E)]
paraVars: [{'2': 'NODE'}, {'1': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, n[1].st = C ->   n[2].st != C), NegExpr(n[2].st = C & x = true), NegExpr(n[2].st = C & n[1].st = E)]
set(self.enum_notEqulVars): {n[2].st, n[1].st}
set(self.enum_EqulVars): {n[2].st, n[2].st', n[1].st, n[1].st'}
self.enum_notEqulVars_map: {'n[2].st': ['C'], 'n[1].st': ['E']}
1111: [And(n[2].st == T, x == True),
 n[2].st' == C,
 x' == False,
 n[2].data' == memDATA,
 n[1].st == n[1].st',
 And(n[2].st' == C, n[1].st' == E),
 Implies(n[1].st == C, n[2].st != C),
 Implies(n[2].st == C, x != True),
 Implies(n[2].st == C, n[1].st != E),
 Or(n[2].data' == 1, n[2].data' == 2),
 Or(memDATA == 1, memDATA == 2)]
checkVars: []
solution: [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, n[1].st, E)]
inv_list [OpExpr(=, n[2].st, T), OpExpr(=, x, true), OpExpr(=, n[1].st, E)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2"
   !(n[1].st = E & x = true & n[2].st = T);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, T), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[2].st, T), OpExpr(=, x, true)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2"
   !(x = true & n[2].st = T);
counter_ex: ['coherence_Crit1_1_Idle1_1_Crit2']
sublist: [OpExpr(=, n[2].st, T), OpExpr(=, n[1].st, E)]
inv_list [OpExpr(=, n[2].st, T), OpExpr(=, n[1].st, E)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2"
   !(n[1].st = E & n[2].st = T);
counter_ex: ['coherence_Crit1_1_Idle1_1_Crit2']
sublist: [OpExpr(=, x, true), OpExpr(=, n[1].st, E)]
inv_list [OpExpr(=, x, true), OpExpr(=, n[1].st, E)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2"
   !(n[1].st = E & x = true);
No cti found. The invariants are OK.
sublist: [OpExpr(=, x, true)]
inv_list [OpExpr(=, x, true)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2"
   !(x = true);
counter_ex: ['coherence_Crit1_1_Idle1_1_Crit2']
sublist: [OpExpr(=, n[1].st, E)]
inv_list [OpExpr(=, n[1].st, E)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2"
   !(n[1].st = E);
counter_ex: ['coherence_Crit1_1_Idle1_1_Crit2']
self.aux_inv1: !(n[1].st = E & x = true)
self.aux_inv2: !(n[1].st = E & x = true)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C'], ['n[_].st = C', 'n[_].st = E'], ['n[_].data != auxDATA', 'n[_].st = E']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}, ('n[_].st = C', 'n[_].st = E'): {}, ('n[_].data != auxDATA', 'n[_].st = E'): {}}
matches: {'n[1].st'}
var.keys(): 2
var.keys(): 1
var_list: []
Oplist: ['n[_].st = E', 'x = true']
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
add pattern: !(n[1].st = E & x = true)
inv_str:
 !(n[1].st = E & x = true)
;
coherence_Crit1_1_Idle1_1_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
current_inv: coherence
val: E <class 'str'>
6. F: [n[1].st == C, n[1].st' == E, n[2].st == n[2].st', And(n[2].st' == C, n[1].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True)]
unsat
coherence_Crit1_1_Idle1_1_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
current_inv: coherence
val: E <class 'str'>
6. F: [n[2].st == C, n[2].st' == E, n[1].st == n[1].st', And(n[2].st' == C, n[1].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True)]
unsat
coherence_Crit1_1_Idle1_1_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
current_inv: coherence
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
6. F: [n[1].st == E, n[1].st' == I, x' == True, memDATA' == n[1].data, n[2].st == n[2].st', And(n[2].st' == C, n[1].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True), Or(memDATA' == 1, memDATA' == 2), Or(n[1].data == 1, n[1].data == 2)]
unsat
coherence_Crit1_1_Idle1_1_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[2].st = C & n[1].st = E))}
current_inv: coherence
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [n[2].st == E, n[2].st' == I, x' == True, memDATA' == n[2].data, n[1].st == n[1].st', And(n[2].st' == C, n[1].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True), Or(memDATA' == 1, memDATA' == 2), Or(n[2].data == 1, n[2].data == 2)]
unsat
list0: {'c51_Crit1_1_Idle1_1': NegExpr(n[1].data != auxDATA & n[1].st = E), 'coherence_Crit1_1_Idle1_1_Crit2_1': NegExpr(n[1].st = E & x = true)}
new_inv: !(n[1].data != auxDATA & n[1].st = E)
c51_Crit1_1_Idle1_1_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA')], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
c51_Crit1_1_Idle1_1_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
c51_Crit1_1_Idle1_1_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [VarExpr('auxDATA')], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
c51_Crit1_1_Idle1_1_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
c51_Crit1_1_Idle1_1_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA')], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
c51_Crit1_1_Idle1_1_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
c51_Crit1_1_Idle1_1_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA')], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
c51_Crit1_1_Idle1_1_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
c51_Crit1_1_Idle1_1_Store1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
c51_Crit1_1_Idle1_1_Store2 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
c51_Crit1_1_Idle1_1_Store3 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
c51_Crit1_1_Idle1_1_Store4 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
booleanExpr_list: [VarExpr('x')]
scalarsetVars: [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('auxDATA')]
list1: {'coherence_Crit1_1_Idle1_1_Crit2_1': NegExpr(n[1].st = E & x = true)}
c51_Crit1_1_Idle1_1_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA')], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
current_inv: c51
val: T <class 'str'>
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[1].st == I, n[1].st' == T, n[1].data == n[1].data', auxDATA == auxDATA', And(n[1].data' != auxDATA', n[1].st' == E), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(n[1].data == 1, n[1].data == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Crit1_1_Idle1_1_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [VarExpr('auxDATA')], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
current_inv: c51
val: C <class 'str'>
val: False <class 'bool'>
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [And(n[1].st == T, x == True), n[1].st' == C, x' == False, n[1].data' == memDATA, auxDATA == auxDATA', And(n[1].data' != auxDATA', n[1].st' == E), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(n[1].data' == 1, n[1].data' == 2), Or(memDATA == 1, memDATA == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[1].data == 1, n[1].data == 2), Or(n[2].data == 1, n[2].data == 2)]
unsat
c51_Crit1_1_Idle1_1_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA')], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
current_inv: c51
val: E <class 'str'>
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[1].st == C, n[1].st' == E, n[1].data == n[1].data', auxDATA == auxDATA', And(n[1].data' != auxDATA', n[1].st' == E), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(n[1].data == 1, n[1].data == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Crit1_1_Idle1_1_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('auxDATA')], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
current_inv: c51
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[1].st == E, n[1].st' == I, x' == True, memDATA' == n[1].data, n[1].data == n[1].data', auxDATA == auxDATA', And(n[1].data' != auxDATA', n[1].st' == E), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(memDATA' == 1, memDATA' == 2), Or(n[1].data == 1, n[1].data == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(auxDATA == 1, auxDATA == 2), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Crit1_1_Idle1_1_Store1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
current_inv: c51
val: 1 <class 'int'>
val: 1 <class 'int'>
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[1].st == C, auxDATA' == 1, n[1].data' == 1, n[1].st == n[1].st', And(n[1].data' != auxDATA', n[1].st' == E), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(auxDATA' == 1, auxDATA' == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Crit1_1_Idle1_1_Store2 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
current_inv: c51
val: 2 <class 'int'>
val: 2 <class 'int'>
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[1].st == C, auxDATA' == 2, n[1].data' == 2, n[1].st == n[1].st', And(n[1].data' != auxDATA', n[1].st' == E), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(auxDATA' == 1, auxDATA' == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(n[1].data == 1, n[1].data == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
unsat
c51_Crit1_1_Idle1_1_Store3 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
current_inv: c51
val: 1 <class 'int'>
val: 1 <class 'int'>
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[2].st == C, auxDATA' == 1, n[2].data' == 1, n[1].data == n[1].data', n[1].st == n[1].st', And(n[1].data' != auxDATA', n[1].st' == E), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data' == 1, n[2].data' == 2), Or(n[1].data == 1, n[1].data == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
sat
解是：

[memDATA = 1,
 x = False,
 auxDATA' = 1,
 n[1].st = E,
 n[1].data = 2,
 n[2].st = C,
 n[1].st' = E,
 n[1].data' = 2,
 n[2].data = 2,
 n[2].data' = 1,
 auxDATA = 2]
invlist1: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].data, 2), OpExpr(=, memDATA, 1), OpExpr(=, x, false)]
paraVars: [{'2': 'NODE'}, {'1': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA)), NegExpr(memDATA != auxDATA & x = true), NegExpr(n[2].st = C & n[1].st = C), NegExpr(n[1].data != auxDATA & n[1].st = E)]
set(self.enum_notEqulVars): {n[1].st}
set(self.enum_EqulVars): {n[2].st, n[1].data, n[1].st, n[1].st'}
self.enum_notEqulVars_map: {'n[1].st': ['C', 'E']}
1111: [n[2].st == C,
 auxDATA' == 1,
 n[2].data' == 1,
 n[1].data == n[1].data',
 n[1].st == n[1].st',
 And(n[1].data' != auxDATA', n[1].st' == E),
 And(Implies(n[1].st == C, n[1].data == auxDATA),
     Implies(n[2].st == C, n[2].data == auxDATA)),
 Implies(memDATA != auxDATA, x != True),
 Implies(n[2].st == C, n[1].st != C),
 Implies(n[1].data != auxDATA, n[1].st != E),
 Or(auxDATA' == 1, auxDATA' == 2),
 Or(n[2].data' == 1, n[2].data' == 2),
 Or(n[1].data == 1, n[1].data == 2),
 Or(n[1].data' == 1, n[1].data' == 2),
 Or(auxDATA == 1, auxDATA == 2),
 Or(n[2].data == 1, n[2].data == 2),
 Or(memDATA == 1, memDATA == 2)]
checkVars: []
solution: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].data, 2), OpExpr(=, memDATA, 1), OpExpr(=, x, false)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].data, 2), OpExpr(=, memDATA, 1), OpExpr(=, x, false)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store3"
   !(x = false & memDATA = 1 & n[2].data = 2 & auxDATA = 2 & n[1].st = E & n[1].data = 2 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].data, 2), OpExpr(=, memDATA, 1)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].data, 2), OpExpr(=, memDATA, 1)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store3"
   !(memDATA = 1 & n[2].data = 2 & auxDATA = 2 & n[1].st = E & n[1].data = 2 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].data, 2)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 2), OpExpr(=, n[2].data, 2)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store3"
   !(n[2].data = 2 & auxDATA = 2 & n[1].st = E & n[1].data = 2 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 2)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 2)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store3"
   !(auxDATA = 2 & n[1].st = E & n[1].data = 2 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, n[1].st, E)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2), OpExpr(=, n[1].st, E)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store3"
   !(n[1].st = E & n[1].data = 2 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 2)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store3"
   !(n[1].data = 2 & n[2].st = C);
counter_ex: ['c51_Crit1_1_Idle1_1_Store3']
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].st, E)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, n[1].st, E)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store3"
   !(n[1].st = E & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[2].st, C)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store3"
   !(n[2].st = C);
counter_ex: ['c51_Crit1_1_Idle1_1_Store3']
sublist: [OpExpr(=, n[1].st, E)]
inv_list [OpExpr(=, n[1].st, E)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store3"
   !(n[1].st = E);
counter_ex: ['c51_Crit1_1_Idle1_1_Store3']
self.aux_inv1: !(n[1].st = E & n[2].st = C)
self.aux_inv2: !(n[1].st = E & n[2].st = C)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C'], ['n[_].st = C', 'n[_].st = E'], ['n[_].data != auxDATA', 'n[_].st = E'], ['n[_].st = E', 'x = true']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}, ('n[_].st = C', 'n[_].st = E'): {}, ('n[_].data != auxDATA', 'n[_].st = E'): {}, ('n[_].st = E', 'x = true'): {}}
matches: {'n[2].st', 'n[1].st'}
var.keys(): 2
var.keys(): 1
var_list: []
Oplist: ['n[_].st = E', 'n[_].st = C']
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
exist self.aux_inv: !(n[1].st = E & n[2].st = C)
c51_Crit1_1_Idle1_1_Store4 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].data != auxDATA & n[1].st = E))}
current_inv: c51
val: 2 <class 'int'>
val: 2 <class 'int'>
data: auxDATA'
equalStates: [auxDATA' == 1, auxDATA' == 2]
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: auxDATA
equalStates: [auxDATA == 1, auxDATA == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [n[2].st == C, auxDATA' == 2, n[2].data' == 2, n[1].data == n[1].data', n[1].st == n[1].st', And(n[1].data' != auxDATA', n[1].st' == E), And(Implies(n[1].st == C, n[1].data == auxDATA),
    Implies(n[2].st == C, n[2].data == auxDATA)), Implies(memDATA != auxDATA, x != True), Implies(n[2].st == C, n[1].st != C), Implies(n[1].data != auxDATA, n[1].st != E), Or(auxDATA' == 1, auxDATA' == 2), Or(n[2].data' == 1, n[2].data' == 2), Or(n[1].data == 1, n[1].data == 2), Or(n[1].data' == 1, n[1].data' == 2), Or(auxDATA == 1, auxDATA == 2), Or(n[2].data == 1, n[2].data == 2), Or(memDATA == 1, memDATA == 2)]
sat
解是：

[x = True,
 memDATA = 1,
 auxDATA' = 2,
 n[1].st = E,
 n[1].data = 1,
 n[2].st = C,
 n[1].st' = E,
 n[1].data' = 1,
 n[2].data = 1,
 n[2].data' = 2,
 auxDATA = 1]
invlist1: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 1), OpExpr(=, memDATA, 1), OpExpr(=, x, true)]
paraVars: [{'2': 'NODE'}, {'1': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, (n[1].st = C ->   n[1].data = auxDATA) & (n[2].st = C ->   n[2].data = auxDATA)), NegExpr(memDATA != auxDATA & x = true), NegExpr(n[2].st = C & n[1].st = C), NegExpr(n[1].data != auxDATA & n[1].st = E)]
set(self.enum_notEqulVars): {n[1].st}
set(self.enum_EqulVars): {n[2].st, n[1].data, n[1].st, n[1].st'}
self.enum_notEqulVars_map: {'n[1].st': ['C', 'E']}
1111: [n[2].st == C,
 auxDATA' == 2,
 n[2].data' == 2,
 n[1].data == n[1].data',
 n[1].st == n[1].st',
 And(n[1].data' != auxDATA', n[1].st' == E),
 And(Implies(n[1].st == C, n[1].data == auxDATA),
     Implies(n[2].st == C, n[2].data == auxDATA)),
 Implies(memDATA != auxDATA, x != True),
 Implies(n[2].st == C, n[1].st != C),
 Implies(n[1].data != auxDATA, n[1].st != E),
 Or(auxDATA' == 1, auxDATA' == 2),
 Or(n[2].data' == 1, n[2].data' == 2),
 Or(n[1].data == 1, n[1].data == 2),
 Or(n[1].data' == 1, n[1].data' == 2),
 Or(auxDATA == 1, auxDATA == 2),
 Or(n[2].data == 1, n[2].data == 2),
 Or(memDATA == 1, memDATA == 2)]
checkVars: []
solution: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 1), OpExpr(=, memDATA, 1), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 1), OpExpr(=, memDATA, 1), OpExpr(=, x, true)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store4"
   !(x = true & memDATA = 1 & n[2].data = 1 & auxDATA = 1 & n[1].st = E & n[1].data = 1 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 1), OpExpr(=, memDATA, 1)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 1), OpExpr(=, memDATA, 1)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store4"
   !(memDATA = 1 & n[2].data = 1 & auxDATA = 1 & n[1].st = E & n[1].data = 1 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 1)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 1), OpExpr(=, n[2].data, 1)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store4"
   !(n[2].data = 1 & auxDATA = 1 & n[1].st = E & n[1].data = 1 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 1)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, n[1].st, E), OpExpr(=, auxDATA, 1)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store4"
   !(auxDATA = 1 & n[1].st = E & n[1].data = 1 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, n[1].st, E)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 1), OpExpr(=, n[1].st, E)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store4"
   !(n[1].st = E & n[1].data = 1 & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 1)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, n[1].data, 1)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store4"
   !(n[1].data = 1 & n[2].st = C);
counter_ex: ['c51_Crit1_1_Idle1_1_Store4']
sublist: [OpExpr(=, n[2].st, C), OpExpr(=, n[1].st, E)]
inv_list [OpExpr(=, n[2].st, C), OpExpr(=, n[1].st, E)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store4"
   !(n[1].st = E & n[2].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, C)]
inv_list [OpExpr(=, n[2].st, C)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store4"
   !(n[2].st = C);
counter_ex: ['c51_Crit1_1_Idle1_1_Store4']
sublist: [OpExpr(=, n[1].st, E)]
inv_list [OpExpr(=, n[1].st, E)]
new_inv: invariant "c51_Crit1_1_Idle1_1_Store4"
   !(n[1].st = E);
counter_ex: ['c51_Crit1_1_Idle1_1_Store4']
self.aux_inv1: !(n[1].st = E & n[2].st = C)
self.aux_inv2: !(n[1].st = E & n[2].st = C)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C'], ['n[_].st = C', 'n[_].st = E'], ['n[_].data != auxDATA', 'n[_].st = E'], ['n[_].st = E', 'x = true']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}, ('n[_].st = C', 'n[_].st = E'): {}, ('n[_].data != auxDATA', 'n[_].st = E'): {}, ('n[_].st = E', 'x = true'): {}}
matches: {'n[2].st', 'n[1].st'}
var.keys(): 2
var.keys(): 1
var_list: []
Oplist: ['n[_].st = E', 'n[_].st = C']
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
exist self.aux_inv: !(n[1].st = E & n[2].st = C)
list0: {'coherence_Crit1_1_Idle1_1_Crit2_1': NegExpr(n[1].st = E & x = true)}
new_inv: !(n[1].st = E & x = true)
coherence_Crit1_1_Idle1_1_Crit2_1_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [VarExpr('x')], '!inv': NegExpr(!(n[1].st = E & x = true))}
coherence_Crit1_1_Idle1_1_Crit2_1_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), VarExpr('x')], '!inv': NegExpr(!(n[1].st = E & x = true))}
coherence_Crit1_1_Idle1_1_Crit2_1_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [], '!inv': NegExpr(!(n[1].st = E & x = true))}
coherence_Crit1_1_Idle1_1_Crit2_1_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & x = true))}
coherence_Crit1_1_Idle1_1_Crit2_1_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [VarExpr('x')], '!inv': NegExpr(!(n[1].st = E & x = true))}
coherence_Crit1_1_Idle1_1_Crit2_1_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), VarExpr('x')], '!inv': NegExpr(!(n[1].st = E & x = true))}
coherence_Crit1_1_Idle1_1_Crit2_1_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [], '!inv': NegExpr(!(n[1].st = E & x = true))}
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & x = true))}
coherence_Crit1_1_Idle1_1_Crit2_1_Store1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), VarExpr('x')], '!inv': NegExpr(!(n[1].st = E & x = true))}
coherence_Crit1_1_Idle1_1_Crit2_1_Store2 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), VarExpr('x')], '!inv': NegExpr(!(n[1].st = E & x = true))}
coherence_Crit1_1_Idle1_1_Crit2_1_Store3 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), VarExpr('x')], '!inv': NegExpr(!(n[1].st = E & x = true))}
coherence_Crit1_1_Idle1_1_Crit2_1_Store4 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), VarExpr('x')], '!inv': NegExpr(!(n[1].st = E & x = true))}
booleanExpr_list: [VarExpr('x')]
scalarsetVars: [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('auxDATA')]
list1: {}
coherence_Crit1_1_Idle1_1_Crit2_1_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [VarExpr('x')], '!inv': NegExpr(!(n[1].st = E & x = true))}
current_inv: coherence
val: T <class 'str'>
6. F: [n[1].st == I, n[1].st' == T, x == x', And(n[1].st' == E, x' == True), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True)]
unsat
coherence_Crit1_1_Idle1_1_Crit2_1_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [], '!inv': NegExpr(!(n[1].st = E & x = true))}
current_inv: coherence
val: C <class 'str'>
val: False <class 'bool'>
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [And(n[1].st == T, x == True), n[1].st' == C, x' == False, n[1].data' == memDATA, And(n[1].st' == E, x' == True), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True), Or(n[1].data' == 1, n[1].data' == 2), Or(memDATA == 1, memDATA == 2)]
unsat
coherence_Crit1_1_Idle1_1_Crit2_1_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & x = true))}
current_inv: coherence
val: C <class 'str'>
val: False <class 'bool'>
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [And(n[2].st == T, x == True), n[2].st' == C, x' == False, n[2].data' == memDATA, n[1].st == n[1].st', And(n[1].st' == E, x' == True), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True), Or(n[2].data' == 1, n[2].data' == 2), Or(memDATA == 1, memDATA == 2)]
unsat
coherence_Crit1_1_Idle1_1_Crit2_1_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [VarExpr('x')], '!inv': NegExpr(!(n[1].st = E & x = true))}
current_inv: coherence
val: E <class 'str'>
6. F: [n[1].st == C, n[1].st' == E, x == x', And(n[1].st' == E, x' == True), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True)]
sat
解是：

[n[2].st = I,
 n[1].st' = E,
 n[1].st = C,
 x = True,
 x' = True]
invlist1: [OpExpr(=, n[1].st, C), OpExpr(=, x, true), OpExpr(=, n[2].st, I)]
paraVars: [{'1': 'NODE'}, {'2': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, n[1].st = C ->   n[2].st != C), NegExpr(n[2].st = C & x = true), NegExpr(n[2].st = C & n[1].st = E), NegExpr(n[1].st = E & x = true)]
set(self.enum_notEqulVars): {n[2].st, n[1].st}
set(self.enum_EqulVars): {n[2].st, x, n[1].st, n[1].st'}
self.enum_notEqulVars_map: {'n[2].st': ['C'], 'n[1].st': ['E']}
1111: [n[1].st == C,
 n[1].st' == E,
 x == x',
 And(n[1].st' == E, x' == True),
 Implies(n[1].st == C, n[2].st != C),
 Implies(n[2].st == C, x != True),
 Implies(n[2].st == C, n[1].st != E),
 Implies(n[1].st == E, x != True)]
checkVars: []
solution: [OpExpr(=, n[1].st, C), OpExpr(=, x, true), OpExpr(=, n[2].st, I)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, x, true), OpExpr(=, n[2].st, I)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2_1_Exit1"
   !(n[2].st = I & x = true & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C), OpExpr(=, x, true)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, x, true)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2_1_Exit1"
   !(x = true & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C)]
inv_list [OpExpr(=, n[1].st, C)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2_1_Exit1"
   !(n[1].st = C);
counter_ex: ['coherence_Crit1_1_Idle1_1_Crit2_1_Exit1']
sublist: [OpExpr(=, x, true)]
inv_list [OpExpr(=, x, true)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2_1_Exit1"
   !(x = true);
counter_ex: ['coherence_Crit1_1_Idle1_1_Crit2_1_Exit1']
self.aux_inv1: !(x = true & n[1].st = C)
self.aux_inv2: !(x = true & n[1].st = C)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C'], ['n[_].st = C', 'n[_].st = E'], ['n[_].data != auxDATA', 'n[_].st = E'], ['n[_].st = E', 'x = true']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}, ('n[_].st = C', 'n[_].st = E'): {}, ('n[_].data != auxDATA', 'n[_].st = E'): {}, ('n[_].st = E', 'x = true'): {}}
matches: {'n[1].st'}
var.keys(): 1
var.keys(): 2
var_list: []
Oplist: ['x = true', 'n[_].st = C']
var出现次数： {}
{}
exist self.aux_inv: !(x = true & n[1].st = C)
coherence_Crit1_1_Idle1_1_Crit2_1_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [], '!inv': NegExpr(!(n[1].st = E & x = true))}
current_inv: coherence
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
6. F: [n[1].st == E, n[1].st' == I, x' == True, memDATA' == n[1].data, And(n[1].st' == E, x' == True), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True), Or(memDATA' == 1, memDATA' == 2), Or(n[1].data == 1, n[1].data == 2)]
unsat
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & x = true))}
current_inv: coherence
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [n[2].st == E, n[2].st' == I, x' == True, memDATA' == n[2].data, n[1].st == n[1].st', And(n[1].st' == E, x' == True), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True), Or(memDATA' == 1, memDATA' == 2), Or(n[2].data == 1, n[2].data == 2)]
sat
解是：

[n[2].data = 1,
 memDATA' = 1,
 n[1].st = E,
 x = False,
 n[1].st' = E,
 x' = True,
 n[2].st' = I,
 n[2].st = E]
invlist1: [OpExpr(=, n[2].st, E), OpExpr(=, n[2].data, 1), OpExpr(=, n[1].st, E), OpExpr(=, x, false)]
invlist2: [OpExpr(=, n[2].st, E), OpExpr(=, n[1].st, E), OpExpr(=, x, false)]
paraVars: [{'2': 'NODE'}, {'1': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, n[1].st = C ->   n[2].st != C), NegExpr(n[2].st = C & x = true), NegExpr(n[2].st = C & n[1].st = E), NegExpr(n[1].st = E & x = true)]
set(self.enum_notEqulVars): {n[2].st, n[1].st}
set(self.enum_EqulVars): {n[2].st, n[2].st', n[1].st, n[1].st'}
self.enum_notEqulVars_map: {'n[2].st': ['C'], 'n[1].st': ['E']}
1111: [n[2].st == E,
 n[2].st' == I,
 x' == True,
 memDATA' == n[2].data,
 n[1].st == n[1].st',
 And(n[1].st' == E, x' == True),
 Implies(n[1].st == C, n[2].st != C),
 Implies(n[2].st == C, x != True),
 Implies(n[2].st == C, n[1].st != E),
 Implies(n[1].st == E, x != True),
 Or(memDATA' == 1, memDATA' == 2),
 Or(n[2].data == 1, n[2].data == 2)]
checkVars: []
solution: [OpExpr(=, n[2].st, E), OpExpr(=, n[1].st, E), OpExpr(=, x, false)]
inv_list [OpExpr(=, n[2].st, E), OpExpr(=, n[1].st, E), OpExpr(=, x, false)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2_1_Idle2"
   !(x = false & n[1].st = E & n[2].st = E);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, E), OpExpr(=, n[1].st, E)]
inv_list [OpExpr(=, n[2].st, E), OpExpr(=, n[1].st, E)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2_1_Idle2"
   !(n[1].st = E & n[2].st = E);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[2].st, E)]
inv_list [OpExpr(=, n[2].st, E)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2_1_Idle2"
   !(n[2].st = E);
counter_ex: ['coherence_Crit1_1_Idle1_1_Crit2_1_Idle2']
sublist: [OpExpr(=, n[1].st, E)]
inv_list [OpExpr(=, n[1].st, E)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2_1_Idle2"
   !(n[1].st = E);
counter_ex: ['coherence_Crit1_1_Idle1_1_Crit2_1_Idle2']
self.aux_inv1: !(n[1].st = E & n[2].st = E)
self.aux_inv2: !(n[1].st = E & n[2].st = E)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C'], ['n[_].st = C', 'n[_].st = E'], ['n[_].data != auxDATA', 'n[_].st = E'], ['n[_].st = E', 'x = true']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}, ('n[_].st = C', 'n[_].st = E'): {}, ('n[_].data != auxDATA', 'n[_].st = E'): {}, ('n[_].st = E', 'x = true'): {}}
matches: {'n[2].st', 'n[1].st'}
var.keys(): 2
var.keys(): 1
var_list: []
Oplist: ['n[_].st = E', 'n[_].st = E']
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
add pattern: !(n[1].st = E & n[2].st = E)
inv_str:
 !(n[1].st = E & n[2].st = E)
;
list0: {'coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1': NegExpr(n[1].st = E & n[2].st = E)}
new_inv: !(n[1].st = E & n[2].st = E)
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Store1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Store2 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Store3 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('1')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('1'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Store4 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(VarExpr('auxDATA'), VarExpr('2')), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('2'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
booleanExpr_list: [VarExpr('x')]
scalarsetVars: [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('auxDATA')]
list1: {}
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Try1 {'guard': OpExpr(=, n[1].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
current_inv: coherence
val: T <class 'str'>
6. F: [n[1].st == I, n[1].st' == T, n[2].st == n[2].st', And(n[1].st' == E, n[2].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True), Implies(n[1].st == E, n[2].st != E)]
unsat
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Try2 {'guard': OpExpr(=, n[2].st, I), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'T'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
current_inv: coherence
val: T <class 'str'>
6. F: [n[2].st == I, n[2].st' == T, n[1].st == n[1].st', And(n[1].st' == E, n[2].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True), Implies(n[1].st == E, n[2].st != E)]
unsat
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Crit1 {'guard': OpExpr(&, n[1].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
current_inv: coherence
val: C <class 'str'>
val: False <class 'bool'>
data: n[1].data'
equalStates: [n[1].data' == 1, n[1].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [And(n[1].st == T, x == True), n[1].st' == C, x' == False, n[1].data' == memDATA, n[2].st == n[2].st', And(n[1].st' == E, n[2].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True), Implies(n[1].st == E, n[2].st != E), Or(n[1].data' == 1, n[1].data' == 2), Or(memDATA == 1, memDATA == 2)]
unsat
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Crit2 {'guard': OpExpr(&, n[2].st = T, x = true), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'C')), AssignCmd(VarExpr('x'), BooleanExpr(False)), AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')), VarExpr('memDATA'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
current_inv: coherence
val: C <class 'str'>
val: False <class 'bool'>
data: n[2].data'
equalStates: [n[2].data' == 1, n[2].data' == 2]
data: memDATA
equalStates: [memDATA == 1, memDATA == 2]
6. F: [And(n[2].st == T, x == True), n[2].st' == C, x' == False, n[2].data' == memDATA, n[1].st == n[1].st', And(n[1].st' == E, n[2].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True), Implies(n[1].st == E, n[2].st != E), Or(n[2].data' == 1, n[2].data' == 2), Or(memDATA == 1, memDATA == 2)]
unsat
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Exit1 {'guard': OpExpr(=, n[1].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
current_inv: coherence
val: E <class 'str'>
6. F: [n[1].st == C, n[1].st' == E, n[2].st == n[2].st', And(n[1].st' == E, n[2].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True), Implies(n[1].st == E, n[2].st != E)]
sat
解是：

[n[1].st' = E, n[1].st = C, n[2].st' = E, n[2].st = E]
invlist1: [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, E)]
paraVars: [{'1': 'NODE'}, {'2': 'NODE'}]
inv already exist: [OpExpr(->, 1 != 2, n[1].st = C ->   n[2].st != C), NegExpr(n[2].st = C & x = true), NegExpr(n[2].st = C & n[1].st = E), NegExpr(n[1].st = E & x = true), NegExpr(n[1].st = E & n[2].st = E)]
set(self.enum_notEqulVars): {n[2].st, n[1].st}
set(self.enum_EqulVars): {n[2].st, n[2].st', n[1].st, n[1].st'}
self.enum_notEqulVars_map: {'n[2].st': ['C', 'E'], 'n[1].st': ['E']}
1111: [n[1].st == C,
 n[1].st' == E,
 n[2].st == n[2].st',
 And(n[1].st' == E, n[2].st' == E),
 Implies(n[1].st == C, n[2].st != C),
 Implies(n[2].st == C, x != True),
 Implies(n[2].st == C, n[1].st != E),
 Implies(n[1].st == E, x != True),
 Implies(n[1].st == E, n[2].st != E)]
checkVars: []
solution: [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, E)]
inv_list [OpExpr(=, n[1].st, C), OpExpr(=, n[2].st, E)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Exit1"
   !(n[2].st = E & n[1].st = C);
No cti found. The invariants are OK.
sublist: [OpExpr(=, n[1].st, C)]
inv_list [OpExpr(=, n[1].st, C)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Exit1"
   !(n[1].st = C);
counter_ex: ['coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Exit1']
sublist: [OpExpr(=, n[2].st, E)]
inv_list [OpExpr(=, n[2].st, E)]
new_inv: invariant "coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Exit1"
   !(n[2].st = E);
counter_ex: ['coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Exit1']
self.aux_inv1: !(n[2].st = E & n[1].st = C)
self.aux_inv2: !(n[2].st = E & n[1].st = C)
invPattern: [['n[_].st = C', 'x = true'], ['memDATA != auxDATA', 'x = true'], ['n[_].st = C', 'n[_].st = C'], ['n[_].st = C', 'n[_].st = E'], ['n[_].data != auxDATA', 'n[_].st = E'], ['n[_].st = E', 'x = true'], ['n[_].st = E', 'n[_].st = E']]
invPattern_dict: {('n[_].st = C', 'x = true'): {}, ('memDATA != auxDATA', 'x = true'): {}, ('n[_].st = C', 'n[_].st = C'): {}, ('n[_].st = C', 'n[_].st = E'): {}, ('n[_].data != auxDATA', 'n[_].st = E'): {}, ('n[_].st = E', 'x = true'): {}, ('n[_].st = E', 'n[_].st = E'): {}}
matches: {'n[2].st', 'n[1].st'}
var.keys(): 1
var.keys(): 2
var_list: []
Oplist: ['n[_].st = E', 'n[_].st = C']
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
var出现次数： {}
{}
exist self.aux_inv: !(n[2].st = E & n[1].st = C)
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Exit2 {'guard': OpExpr(=, n[2].st, C), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'E'))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
current_inv: coherence
val: E <class 'str'>
6. F: [n[2].st == C, n[2].st' == E, n[1].st == n[1].st', And(n[1].st' == E, n[2].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True), Implies(n[1].st == E, n[2].st != E)]
unsat
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Idle1 {'guard': OpExpr(=, n[1].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
current_inv: coherence
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[1].data
equalStates: [n[1].data == 1, n[1].data == 2]
6. F: [n[1].st == E, n[1].st' == I, x' == True, memDATA' == n[1].data, n[2].st == n[2].st', And(n[1].st' == E, n[2].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True), Implies(n[1].st == E, n[2].st != E), Or(memDATA' == 1, memDATA' == 2), Or(n[1].data == 1, n[1].data == 2)]
unsat
coherence_Crit1_1_Idle1_1_Crit2_1_Idle2_1_Idle2 {'guard': OpExpr(=, n[2].st, E), 'assign': [AssignCmd(FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'st')), EnumValExpr(EnumType('I', 'T', 'C', 'E'), 'I')), AssignCmd(VarExpr('x'), BooleanExpr(True)), AssignCmd(VarExpr('memDATA'), FieldName(ArrayIndex(VarExpr('n'), VarExpr('2')), Token('CNAME', 'data')))], 'assumption': [FieldName(ArrayIndex(VarExpr('n'), VarExpr('1')), Token('CNAME', 'st'))], '!inv': NegExpr(!(n[1].st = E & n[2].st = E))}
current_inv: coherence
val: I <class 'str'>
val: True <class 'bool'>
data: memDATA'
equalStates: [memDATA' == 1, memDATA' == 2]
data: n[2].data
equalStates: [n[2].data == 1, n[2].data == 2]
6. F: [n[2].st == E, n[2].st' == I, x' == True, memDATA' == n[2].data, n[1].st == n[1].st', And(n[1].st' == E, n[2].st' == E), Implies(n[1].st == C, n[2].st != C), Implies(n[2].st == C, x != True), Implies(n[2].st == C, n[1].st != E), Implies(n[1].st == E, x != True), Implies(n[1].st == E, n[2].st != E), Or(memDATA' == 1, memDATA' == 2), Or(n[2].data == 1, n[2].data == 2)]
unsat
times of calling SMT: 72
times of calling LocalSearch: 144
